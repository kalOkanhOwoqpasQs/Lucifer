
local bot = getBot()
local inventory = getBot():getInventory()
local printed = getBot():getLog()

for index, botName in pairs(getBots()) do
    if bot.name:upper() == botName.name:upper() then
        pcallBot = index
    end
end

local strGenerate = ''
for i = 1,10 do
    strGenerate = strGenerate..string.char(math.random(97,122))
end
strFormatted = 'Harvesting.....'
botBackup = {}
initialize = {}
tblMessage = {}

local customizable = {
    seed = block + 1,
    index = 1,
    indexPack = 0,
    indexSeed = 0,
    indexBlock = 0,
    indexEvent = 0,
    indexMessage = 1,
    indexBackup = 1,
    variableBlock = 1,
    variableSeed = 1,
    variablePack = 1,
    variableEvent = 1,
    formatTime = os.time(),
    seedX = dropseedX - 1,
    seedY = dropseedY - 1,
    packX = droppackX - 1,
    packY = droppackY - 1,
    blockX = dropblockX - 1,
    blockY = dropblockY - 1,
    eventX = dropeventX - 1,
    eventY = dropeventY -1
}
local events = {
    onNuke = function(variant,netid)
        if variant:get(0):getString() == 'OnConsoleMessage' then
            if variant:get(1):getString():lower():find('inaccessible.') or variant:get(1):getString():lower():find('unknown reason.') then
                nuked = true
            end
            unlistenEvents()
        end
    end,
    onCreateWorld = function(variant,netid)
        if variant:get(0):getString() == 'OnConsoleMessage' then
            if variant:get(1):getString():lower():find('created too many worlds') or variant:get(1):getString():lower():find('unknown reason.') then
                maxfind = true
            end
            unlistenEvents()
        end
    end
} 

bot.legit_mode = false
bot.move_range = moveRange
bot.move_interval = moveInterval
bot.auto_reconnect = true
bot.collect_range = range
if ignoregems then
    bot.ignore_gems = true
end

for i =  1,customizable.indexMessage do
    table.insert(tblMessage,messageidbotinfo[math.floor((pcallBot - 1) * customizable.indexMessage + i)])
end

itemFloat = function(id)
    return bot:getWorld().growscan:getObjects()[id] or 0
end

notifications = function(desc)
    messageBox = MessageBox.new()
    messageBox.title = 'Caramoy Syndicate'
    messageBox.description = desc
    messageBox:send()
end

isHarvested = function(ex,ye)
    return getTile(ex,ye).fg == customizable.seed and getTile(ex,ye):canHarvest() and bot:getWorld():hasAccess(ex,ye) > 0 and getTile(ex,ye).flags < 4096
end

local function readFile(fileContents, fileNames)
    local allFilesContents = {}
    for i, fileName in ipairs(fileNames) do
        local file = io.open(fileName, 'r')
        if not file then
            notifications('Fail to open file '..fileName..'.')
            return nil
        else
            local fileContent = {}
            for line in file:lines() do
                table.insert(fileContent, line)
            end
            file:close()
            table.insert(fileContents, fileContent)
        end
    end
    return fileContents
end

if autoSwitch then
    local switchTable = {}
    local files = {switchFile}
    local text = readFile({},files)
    if text then
        for i, fileContent in ipairs(text) do
            for _, line in ipairs(fileContent) do
                table.insert(switchTable,line)
            end
        end
    end
    local onIndex = pcallBot - 1
    local onSplit = #switchTable / #getBots()
    local onStart = math.floor(onIndex * onSplit + 1)
    local onStop = math.floor(onIndex + 1) * onSplit
    for i = onStart, onStop do
        table.insert(botBackup,switchTable[i])
    end
end

local farmTable = {}
local files = {worldFile}
local text = readFile({},files)
if text then
    for i, fileContent in ipairs(text) do
        for _, line in ipairs(fileContent) do
            table.insert(farmTable,line)
        end
    end
end
local index = pcallBot - 1
local split = #farmTable / #getBots()
local start = math.floor(index * split + 1)
local stop = math.floor(index + 1) * split

itemRecycle = function()
    if inventory:getItemCount(block) > 0 then
        bot:sendPacket(2,'action|trash\n|itemID|'..block)
        sleep(500)
        bot:sendPacket(2,'action|dialog_return\ndialog_name|trash_item\nitemID|' .. block .. '|\ncount|' .. inventory:getItemCount(block))
        sleep(500)
    end
end

writeFile = function(filename,threads)
    local file = io.open(filename..'.txt','a')
    file:write(threads..'\n')
    file:close()
end

setAuth = function()
    if withproxy then
        getProxyManager():setLimit(botperproxy)
        for idx, value in pairs(proxyList) do
            getProxyManager():addProxy(value)
        end
    end
end

splitPattern = function(str, ptr)
    if not ptr then 
        ptr = '%s'
    end
    local tbl = {}
    for string in string.gmatch(str, ptr) do
        table.insert(tbl, string) 
    end
    return tbl
end

clientStatic = function()
    local desc = bot.status
    if desc == BotStatus.offline then
        return 'Offline'
    elseif desc == BotStatus.account_banned then
        return 'Suspended'
    elseif desc == BotStatus.location_banned then
        return 'Location Banned'
    elseif desc == BotStatus.too_many_login then
        return 'Too Many Login'
    elseif desc == BotStatus.maintenance then
        return 'Maintenance'
    elseif desc == BotStatus.error_connecting then
        return 'Error Connecting'
    elseif desc == BotStatus.http_block then
        return 'HTTP Block'
    elseif desc == BotStatus.changing_subserver then
        return 'Changing Subserver'
    elseif desc == BotStatus.mod_entered then
        return 'Mod Entered'
    else
        return 'Online'
    end
end

onTileWorld = function()
    local tiles = {}
    local botPos = {}
    local onPosAlr = function(tbl, x, y)
        return not botPos[x] or not botPos[x][y]
    end
    if not multiplebot then
        for y = 0, 53 do 
            if (y % 4 == 1) then
                for x = 0, 99 do
                    table.insert(tiles, { x = x, y = y })
                    botPos[x] = botPos[x] or {}
                    botPos[x][y] = true
                end
            else
                for x = 99, 0, -1 do
                    table.insert(tiles, { x = x, y = y })
                    botPos[x] = botPos[x] or {}
                    botPos[x][y] = true
                end
            end
        end
    else
        for tbl = 0, 1 do
            for y = tbl + ((pcallBot - 1) * 2), 53, #getBots() * 2 do
                if (y % 4 == 1) then
                    for x = 0, 99 do
                        table.insert(tiles, { x = x, y = y })
                        botPos[x] = botPos[x] or {}
                        botPos[x][y] = true
                    end
                else
                    for x = 99, 0, -1 do
                        table.insert(tiles, { x = x, y = y })
                        botPos[x] = botPos[x] or {}
                        botPos[x][y] = true
                    end
                end
            end
        end
    end
    return tiles
end
local tiles = onTileWorld()

tableFormatted = function(time)
    if strFormatted == 'Harvesting.....' then
        strFormatted = ''
    end
    strFormatted = strFormatted .. time .. '\n'
end

localInfo = function(info)
    local globalInfo = function(values)
        str = ''
        if values == 'switch' then
            if autoSwitch then
                for i = 1,#botBackup do
                    str = str..'\n||'..string.upper(splitPattern(botBackup[i],'[^|]+')[1])..'|| ('..(initialize[splitPattern(botBackup[i],'[^|]+')[1]] or '?')..')'
                end
            else
                return 'Not using switch'
            end
        elseif values == 'block' then
            for i = 1, #storageblock do
                str = str..'\n||'..string.upper(splitPattern(storageblock[i],'[^|]+')[1])..'|| : '..(initialize[splitPattern(storageblock[i],'[^|]+')[1]] or '?')..''
            end
        elseif values == 'seed' then
            for i = 1, #storageseed do
                str = str..'\n||'..string.upper(splitPattern(storageseed[i],'[^|]+')[1])..'|| : '..(initialize[splitPattern(storageseed[i],'[^|]+')[1]] or '?')..''
            end
        elseif values == 'pack' then
            if splitPattern(storagepack[customizable.index],'[^|]+')[1] ~= 'x' then
                for i = 1, #storagepack do
                    str = str..'\n||'..string.upper(splitPattern(storagepack[i],'[^|]+')[1])..'|| : '..(initialize[splitPattern(storagepack[i],'[^|]+')[1]] or '?')..''
                end
            else
                return 'Not using Storage Packs'
            end
        elseif values == 'event' then
            if splitPattern(storageevent[customizable.index],'[^|]+')[1] ~= 'x' then
                for i = 1, #storageevent do
                    str = str..'\n||'..string.upper(splitPattern(storageevent[i],'[^|]+')[1])..'|| : '..(initialize[splitPattern(storageevent[i],'[^|]+')[1]] or '?')..''
                end
            else
                return 'Not using Storage Events'
            end
        end
        return str
    end
	if linkbotinfo ~= 'x' then
        realtime = os.time() - customizable.formatTime
        for _, value in pairs(tblMessage) do
            local webhook = Webhook.new(linkbotinfo)
            webhook.embed1.use = true
            webhook.embed2.use = true
            webhook.embed1.thumbnail = 'https://cdn.discordapp.com/attachments/1222249842387193876/1224708077262082068/Hnet.com-image.jpg?ex=661e7947&is=660c0447&hm=e692ab165629d6a84ca2661b5b4a75f97a23cfabb98983fda3270bc2be0e7474&'
            webhook.embed1:addField("Bot Task",info,false)
            webhook.embed1:addField("Bot Name",'||'..string.sub(bot.name,1,5)..'||',true)
            webhook.embed1:addField('Bot Current','||'..string.sub(getWorld().name,1,5)..'||',true)
            webhook.embed1:addField('Bot Status',clientStatic(),true)
            webhook.embed1:addField('Bot Level',bot.level,true)
            webhook.embed1:addField('Bot Age',bot:getAge()..' Days',true)
            webhook.embed1:addField('Bot Uptime',math.floor(realtime/86400)..':'..math.floor(realtime%86400/3600)..':'..math.floor(realtime%86400%3600/60)..'',true)
            webhook.embed1:addField('Storage Seed',globalInfo('seed'),true)
            webhook.embed1:addField('Storage Pack',globalInfo('pack'),true)
            webhook.embed1:addField('Storage Event',globalInfo('event'),true)
            webhook.embed1:addField('Storage Block',globalInfo('block'),false)
            webhook.embed2:addField('Farm Estimates',strFormatted,true)
            webhook.embed2:addField('Switch Account',globalInfo('switch'),true)
            webhook.embed2.footer.icon_url = 'https://cdn.discordapp.com/attachments/1222249842387193876/1224708077706543236/1712025730898.jpg?ex=661e7947&is=660c0447&hm=3be9efe2f0f23456f272149dc0844db884cee12f3b21199b35b2c1287c77a8f2&'
            webhook.embed2.footer.text = '[Lucifer Harvest]\nDeveloped By Caramoy and Made With Luv<3'
            webhook:edit(value)
        end    
    end
end

clientContent = function(text)
    if webhookstatuslink ~= 'x'  then
        local webhook = Webhook.new(webhookstatuslink)
        webhook.content = '@everyone'
        webhook.embed1.use = true
        webhook.embed1:addField('',text,false)
        webhook.embed1.footer.text = 'Webhook Status, sent at : '..(os.date('!%a %b %d, %Y at %I:%M %p', os.time() + 7 * 60 * 60))..''
        webhook:send()
    end
end

textInfo = function(str,alphabet)
    printed:append(alphabet)
    clientContent('('..string.upper(bot.name)..') '..alphabet)
    if str == 'stop' then
        notifications(string.upper(bot.name)..' : '..alphabet)
        error(alphabet)
    end
end

detectTable = function(items,amt)
    for _, init in pairs(items) do
        if inventory:getItemCount(init) >= amt then
            return true
        end
    end
    return false
end

clientStatus = function()
    if bot.status ~= BotStatus.online then
        bot.auto_reconnect = false
        textInfo('','status is '..clientStatic()..', Current : '..getWorld().name..'')
        localInfo('Bot Status is '..clientStatic())
        while bot.status ~= BotStatus.online do
            bot:connect()
            sleep(5000)
            if bot.status == BotStatus.account_banned then
                textInfo('stop','status is '..clientStatic()..'')
            elseif bot.status == BotStatus.maintenance then
                textInfo('','Server is maintenance, Sleeping for '..delaymaintenance..' minutes')
                sleep(delaymaintenance * 60000)
            elseif bot.status ~= BotStatus.online then
                sleep(delayreconnect * 1000)
            elseif bot.status == BotStatus.online then
                sleep(5000)
                break
            end
        end
        textInfo('','status is '..clientStatic()..', Current : '..getWorld().name..'')
        bot.auto_reconnect = true
    end
end

reconnect = function(world,id,x,y)
    if bot.status ~= BotStatus.online then
        clientStatus()
    end
    if not bot:isInWorld(world:upper()) then
        addEvent(Event.variantlist, events.onNuke)
        addEvent(Event.variantlist, events.onCreateWorld)
        while not bot:isInWorld(world:upper()) and not nuked and not maxfind do
            bot:warp(world:upper())
            listenEvents(5)
            sleep(delaywarp * 1000)
        end
        removeEvent(Event.variantlist)
    end
    if bot:isInWorld(world:upper()) then
        if id ~= '' then
            while getTile(bot.x,bot.y).fg == 6 do
                bot:warp(world:upper(),id:upper())
                sleep(delaywarp * 1000)
            end
        end
        if x and y then
            while bot.x ~= x or bot.y ~= y do
                bot:findPath(x,y)
                sleep(150)
            end
        end
    end
end

warp = function(world,door)
    name = world
    if door ~= '' then
        name = name .. '|' ..door
    end
    if not bot:isInWorld(world:upper()) then
        count = 0
        addEvent(Event.variantlist, events.onNuke)
        addEvent(Event.variantlist, events.onCreateWorld)
        while not bot:isInWorld(world:upper()) and not nuked and not maxfind do
            clientStatus()
            bot:warp(name)
            listenEvents(5)
            sleep(delaywarp * 1000)
            count = count + 1
            if count == 15 then
                count = 0
                textInfo('',': Maybe hard warp?, disconnecting bot and sleeping for '..delayidiotserver..' minutes')
                bot:disconnect()
                sleep(delayidiotserver * 60000)
            end
        end
        removeEvent(Event.variantlist)
    end
    if bot:isInWorld(world:upper()) and door ~= '' then
        local stuck  = 0
        while getTile(bot.x,bot.y).fg == 6 and not wrong do
            clientStatus()
            bot:warp(name)
            sleep(delaywarp * 1000)
            stuck = stuck + 1
            if stuck == 5 then
                wrong = true
            end
        end
    end
end

shortcut = function(thread,id)
    printed:append('Harvesting')
    warp(thread,id)
    localInfo('Harvesting')
    bot.auto_collect = true
end

joinRandom = function()
    if clearhistory then
        printed:append('Clearing history')
        localInfo('Clearing history')
        for _, value in pairs(worldclearhistory) do
            warp(value,'')
            if not maxfind then
                if not nuked then
                    reconnect(value,'')
                else
                    nuked = false
                    textInfo('stop','World clearing history has nuked, Script terminated.')
                end
            else
                maxfind = false
                textInfo('stop','Too many creating worlds today, Script terminated.')
            end
        end
    end
end

buying = function()
    printed:append('Buying packs')
    localInfo('Buying Pack')
    if upbackpack and inventory.slotcount < 36 then
        printed:append('Upgrading backpacks')
        repeat
            bot:sendPacket(2,'action|buy\nitem|upgrade_backpack')
            sleep(1000)
        until inventory.slotcount >= 36
    end
    while bot.gem_count >= pricepack do
        bot:sendPacket(2,'action|buy\nitem|'..debug)
        sleep(1000)
        if detectTable(packList,200) then
            break
        end
    end
end

onEvent = function(thread,id)
    printed:append('Dropping events')
    for i = customizable.variableEvent , #storageevent do
        world = splitPattern(storageevent[i],'[^|]+')[1]
        door = splitPattern(storageevent[i],'[^|]+')[2]
        bot.auto_collect = false
        warp(world,door)
        if not nuked then
            if not wrong then
                localInfo('Dropping Events')
                if itemFloat(eventList[1]) >= limitevent then
                    initialize[world] = itemFloat(eventList[1])..'x [LIMIT]'
                    textInfo('','Storage event : '..world..' has reached limit, skipped world')
                    customizable.variableEvent = customizable.variableEvent + 1
                    customizable.indexEvent = 0
                    if customizable.variableEvent > #storageevent then
                        initialize[world] = itemFloat(eventList[1])..'x [LIMIT]'
                        if removingbot then
                            removeBot()
                            sleep(2000)
                        else
                            warp(strGenerate,'')
                        end
                        localInfo('All events storage has reached limit')
                        textInfo('stop','All events storage has reached limit, Script terminated.')
                    end
                else
                    for y,pack in pairs(eventList) do
                        for i,tile in pairs(bot:getWorld():getTiles()) do
                            if tile.fg == 0 or tile.bg == 0 then
                                ::BACK::
                                bot:findPath(customizable.eventX + (customizable.indexEvent),customizable.eventY)
                                sleep(100)
                                local count = 0
                                reconnect(world,door,customizable.eventX + (customizable.indexEvent),customizable.eventY)
                                if customizable.eventX + (customizable.indexEvent) >= 98 then
                                    customizable.eventY = customizable.eventY - 1
                                    customizable.indexEvent = 0
                                end
                                while inventory:getItemCount(pack) > 0 do
                                    bot:setDirection(false)
                                    bot:drop(pack,200)
                                    sleep(delaydrop * 1000)
                                    reconnect(world,door,customizable.eventX + (customizable.indexEvent),customizable.eventY)
                                    count = count + 1
                                    if count >= 2 then
                                        customizable.indexEvent = customizable.indexEvent + 1
                                        goto BACK
                                    end
                                end
                            end
                            if inventory:getItemCount(pack) == 0 then
                                break
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                textInfo('','Storage event : '..world..' are wrong door id, Skipped world.')
                customizable.variableEvent = customizable.variableEvent + 1
                customizable.indexEvent = 0
                if customizable.variableEvent > #storageevent then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    else
                        warp(strGenerate,'')
                    end
                    localInfo('All events storage has reached limit')
                    textInfo('stop','All events storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            textInfo('','Storage event : '..world..' are Nuked, Skipped world.')
            customizable.variableEvent = customizable.variableEvent + 1
            customizable.indexEvent = 0
            if customizable.variableEvent > #storageevent then
                if removingbot then
                    removeBot()
                    sleep(2000)
                else
                    warp(strGenerate,'')
                end
                localInfo('All events storage has reached limit')
                textInfo('stop','All events storage has reached limit')
            end
        end 
    end
    initialize[world] = itemFloat(eventList[1])..'x'
    joinRandom()
    shortcut(thread,id)
end

onPack = function(thread,id)
    printed:append('Dropping packs')
    for i = customizable.variablePack , #storagepack do
        world = splitPattern(storagepack[i],'[^|]+')[1]
        door = splitPattern(storagepack[i],'[^|]+')[2]
        bot.auto_collect = false
        warp(world,door)
        if not nuked then
            if not wrong then
                localInfo('Dropping packs')
                if itemFloat(packList[1]) >= limitpack then
                    initialize[world] = itemFloat(packList[1])..'x [LIMIT]'
                    textInfo('','Storage packs : '..world..' has reached limit, skipped world')
                    customizable.variablePack = customizable.variablePack + 1
                    customizable.indexPack = 0
                    if customizable.variablePack > #storagepack then
                        initialize[world] = itemFloat(packList[1])..'x [LIMIT]'
                        if removingbot then
                            removeBot()
                            sleep(2000)
                        else
                            warp(strGenerate,'')
                        end
                        localInfo('All packs storage has reached limit')
                        textInfo('stop','All packs storage has reached limit')
                    end
                else
                    for y,pack in pairs(packList) do
                        for i,tile in pairs(bot:getWorld():getTiles()) do
                            if tile.fg == 0 or tile.bg == 0 then
                                ::BACK::
                                bot:findPath(customizable.packX + (customizable.indexPack),customizable.packY)
                                sleep(100)
                                local count = 0
                                reconnect(world,door,customizable.packX + (customizable.indexPack),customizable.packY)
                                if customizable.packX + (customizable.indexPack) >= 98 then
                                    customizable.packY = customizable.packY - 1
                                    customizable.indexPack = 0
                                end
                                while inventory:getItemCount(pack) > 0 do
                                    bot:setDirection(false)
                                    bot:drop(pack,200)
                                    sleep(delaydrop * 1000)
                                    reconnect(world,door,customizable.packX + (customizable.indexPack),customizable.packY)
                                    count = count + 1
                                    if count >= 2 then
                                        customizable.indexPack = customizable.indexPack + 1
                                        goto BACK
                                    end
                                end
                            end
                            if inventory:getItemCount(pack) == 0 then
                                break
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                textInfo('','Storage packs : '..world..' are wrong door id, Skipped world.')
                customizable.variablePack = customizable.variablePack + 1
                customizable.indexPack = 0
                if customizable.variablePack > #storagepack then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    else
                        warp(strGenerate,'')
                    end
                    localInfo('All packs storage has reached limit')
                    textInfo('stop','All packs storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            textInfo('','Storage packs : '..world..' are Nuked, Skipped world.')
            customizable.variablePack = customizable.variablePack + 1
            customizable.indexPack = 0
            if customizable.variablePack > #storagepack then
                if removingbot then
                    removeBot()
                    sleep(2000)
                else
                    warp(strGenerate,'')
                end
                localInfo('All packs storage has reached limit')
                textInfo('stop','All packs storage has reached limit')
            end
        end 
    end
    initialize[world] = itemFloat(packList[1])..'x'
    joinRandom()
    shortcut(thread,id)
end

onSeed = function(thread,id)
    printed:append('Dropping seeds')
    for i = customizable.variableSeed , #storageseed do
        world = splitPattern(storageseed[i],'[^|]+')[1]
        door = splitPattern(storageseed[i],'[^|]+')[2]
        bot.auto_collect = false
        warp(world,door)
        if not nuked then
            if not wrong then
                localInfo('Dropping seeds')
                if itemFloat(customizable.seed) >= limitseed then
                    initialize[world] = itemFloat(customizable.seed)..'x [LIMIT]'
                    textInfo('','Storage seeds : '..world..' has reached limit, skipped world')
                    customizable.variableSeed = customizable.variableSeed + 1
                    customizable.indexSeed = 0
                    if customizable.variableSeed > #storageseed then
                        initialize[world] = itemFloat(customizable.seed)..'x [LIMIT]'
                        if removingbot then
                            removeBot()
                            sleep(2000)
                        else
                            warp(strGenerate,'')
                        end
                        localInfo('All seeds storage has reached limit')
                        textInfo('stop','All seeds storage has reached limit')
                    end
                else
                    for i,tile in pairs(bot:getWorld():getTiles()) do
                        if tile.fg == 0 or tile.bg == 0 then
                            ::BACK::
                            bot:findPath(customizable.seedX + (customizable.indexSeed),customizable.seedY)
                            sleep(100)
                            local count = 0
                            reconnect(world,door,customizable.seedX + (customizable.indexSeed),customizable.seedY)
                            if customizable.seedX + (customizable.indexSeed) >= 98 then
                                customizable.seedY = customizable.seedY - 1
                                customizable.indexSeed = 0
                            end
                            while inventory:getItemCount(customizable.seed) > 0 do
                                bot:setDirection(false)
                                bot:drop(customizable.seed,200)
                                sleep(delaydrop * 1000)
                                reconnect(world,door,customizable.seedX + (customizable.indexSeed),customizable.seedY)
                                count = count + 1
                                if count >= 2 then
                                    customizable.indexSeed = customizable.indexSeed + 1
                                    goto BACK
                                end
                            end
                        end
                        if inventory:getItemCount(customizable.seed) == 0 then
                            break
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                textInfo('','Storage seeds : '..world..' are wrong door id, Skipped world.')
                customizable.variableSeed = customizable.variableSeed + 1
                customizable.indexSeed = 0
                if customizable.variableSeed > #storageseed then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    else
                        warp(strGenerate,'')
                    end
                    localInfo('All seeds storage has reached limit')
                    textInfo('stop','All seeds storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            textInfo('','Storage seeds : '..world..' are Nuked, Skipped world.')
            customizable.variableSeed = customizable.variableSeed + 1
            customizable.indexSeed = 0
            if customizable.variableSeed > #storageseed then
                if removingbot then
                    removeBot()
                    sleep(2000)
                else
                    warp(strGenerate,'')
                end
                localInfo('All seeds storage has reached limit')
                textInfo('stop','All seeds storage has reached limit')
            end
        end 
    end
    initialize[world] = itemFloat(customizable.seed)..'x'
    joinRandom()
    shortcut(thread,id)
end

onBlock = function(thread,id)
    printed:append('Dropping blocks')
    for i = customizable.variableBlock , #storageblock do
        world = splitPattern(storageblock[i],'[^|]+')[1]
        door = splitPattern(storageblock[i],'[^|]+')[2]
        bot.auto_collect = false
        warp(world,door)
        if not nuked then
            if not wrong then
                localInfo('Dropping blocks')
                if itemFloat(block) >= limitblock then
                    initialize[world] = itemFloat(block)..'x [LIMIT]'
                    textInfo('','Storage blocks : '..world..' has reached limit, skipped world')
                    customizable.variableBlock = customizable.variableBlock + 1
                    customizable.indexBlock = 0
                    if customizable.variableBlock > #storageblock then
                        initialize[world] = itemFloat(block)..'x [LIMIT]'
                        if removingbot then
                            removeBot()
                            sleep(2000)
                        else
                            warp(strGenerate,'')
                        end
                        localInfo('All blocks storage has reached limit')
                        textInfo('stop','All blocks storage has reached limit')
                    end
                else
                    for i,tile in pairs(bot:getWorld():getTiles()) do
                        if tile.fg == 0 or tile.bg == 0 then
                            ::BACK::
                            bot:findPath(customizable.blockX + (customizable.indexBlock),customizable.blockY)
                            sleep(100)
                            local count = 0
                            reconnect(world,door,customizable.blockX + (customizable.indexBlock),customizable.blockY)
                            if customizable.blockX + (customizable.indexBlock) >= 98 then
                                customizable.blockY = customizable.blockY - 1
                                customizable.indexBlock = 0
                            end
                            while inventory:getItemCount(block) > 0 do
                                bot:setDirection(false)
                                bot:drop(block,200)
                                sleep(delaydrop * 1000)
                                reconnect(world,door,customizable.blockX + (customizable.indexBlock),customizable.blockY)
                                count = count + 1
                                if count >= 2 then
                                    customizable.indexBlock = customizable.indexBlock + 1
                                    goto BACK
                                end
                            end
                        end
                        if inventory:getItemCount(block) == 0 then
                            break
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                textInfo('','Storage blocks : '..world..' are wrong door id, Skipped world.')
                customizable.variableBlock = customizable.variableBlock + 1
                customizable.indexBlock = 0
                if customizable.variableBlock > #storageblock then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    else
                        warp(strGenerate,'')
                    end
                    localInfo('All blocks storage has reached limit')
                    textInfo('stop','All blocks storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            textInfo('','Storage blocks : '..world..' are Nuked, Skipped world.')
            customizable.variableBlock = customizable.variableBlock + 1
            customizable.indexBlock = 0
            if customizable.variableBlock > #storageblock then
                if removingbot then
                    removeBot()
                    sleep(2000)
                else
                    warp(strGenerate,'')
                end
                localInfo('All blocks storage has reached limit')
                textInfo('stop','All blocks storage has reached limit')
            end
        end 
    end
    initialize[world] = itemFloat(block)..'x'
    joinRandom()
    shortcut(thread,id)
end

wearingItemEvent = function(thread,id)
    printed:append('Take support items')
    world = splitPattern(worldwearitem[customizable.index],'[^|]+')[1]
    door = splitPattern(worldwearitem[customizable.index],'[^|]+')[2]
    bot.auto_collect = false
    bot.collect_range = 10
    warp(world,door)
    if not nuked then
        if not wrong then
            if inventory:getItemCount(idItemSupport) == 0 and itemFloat(idItemSupport) >= keepItemSupport then
                while bot:collectByID(idItemSupport) do
                    sleep(500)
                    reconnect(world,door,bot.x,bot.y)
                end
                bot:moveTo(1,0)
                sleep(500)
                bot:wear(idItemSupport)
                bot:setDirection(true)
                sleep(300)
                bot:drop(idItemSupport,inventory:getItemCount(idItemSupport) - keepItemSupport)
                sleep(1000)
                reconnect(world,door,bot.x,bot.y)
            else
                textInfo('','Support item is empty, Drop the support item right now! Bot sleeping for 30 seconds')
                sleep(30000)
            end
        else
            wrong = false
            textInfo('stop','Id door world take support items is wrong, check ur id door! Terminated script.')
        end
    else
        nuked = false
        textInfo('stop','World take support items is nuked, check ur world! Terminated script.')
    end
    bot.collect_range = range
    shortcut(thread,id)
end

onBackup = function(world,id)
    printed:append('Bot : '..bot.name..' reached max level, switching bot')
    ::BACK::
    for idx = customizable.indexBackup, #botBackup do
        thread = splitPattern(botBackup[idx],'([^|]+)')[1]
        threading = splitPattern(botBackup[idx],'([^|]+)')[2]
        if typeaccount == 'normal' then
            bot:updateBot(thread,threading)
        elseif typeaccount == 'guest' then
            bot:updateBot(strGenerate,thread,threading)
        end
        sleep(delayloginbot * 1000)
        bot.auto_reconnect = false
        textInfo('','Succes switching bot to > '..bot.name..'')
        while bot.status ~= BotStatus.online do
            bot:connect()
            if bot.status == BotStatus.account_banned then
                initialize[thread] = 'Suspended'
                writeFile('switchStatus',thread..' : status is Suspended')
                textInfo('','Bot : '..thread..' is suspended, skipped bot')
                customizable.indexBackup = customizable.indexBackup + 1
                if customizable.indexBackup > #botBackup then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    end
                    localInfo('No more bots to switch, sc terminated')
                    textInfo('stop','No more bots to switch, sc terminated')
                end
                goto BACK
            else
                sleep(delayreconnect * 1000)
            end
        end
        if bot.status == BotStatus.online and bot.level < switchOnLevel then
            initialize[thread] = 'Used'
            break
        elseif bot.status == BotStatus.online and bot.level >= switchOnLevel then
            initialize[thread] = 'Reached max level'
            customizable.indexBackup = customizable.indexBackup + 1
            if customizable.indexBackup > #botBackup then
                if removingbot then
                    removeBot()
                    sleep(2000)
                end
                localInfo('No more bots to switch, sc terminated')
                textInfo('stop','No more bots to switch, sc terminated')
            end
            goto BACK
        end
    end
    shortcut(world,id)
end

saveFile = function(init,str)
    writeFile('WorldInfo',init..' : is '..str)
    tableFormatted(string.sub(init,1,3)..' | '..str)
    textInfo('',init.. ' : is '..str..', skipped world')
end

inventoryItems = function(thread,id)
    if inventory:getItemCount(idItemSupport) == 0 and wearingItemSupport then
        while inventory:getItemCount(idItemSupport) == 0 do
            wearingItemEvent(thread,id)
        end
    elseif autoSwitch and bot.level >= switchOnLevel then
        if inventory:getItemCount(block) > 0 then
            onBlock(thread,id)
        end
        if inventory:getItemCount(customizable.seed) > 0 then
            onSeed(thread,id)
        end
        onBackup(thread,id)
    elseif inventory:getItemCount(block) >= amountBlock then
        if recycle then
            itemRecycle()
        else
            onBlock(thread,id)
        end
    elseif detectTable(eventList,amountEvent) then
        onEvent(thread,id)
    elseif inventory:getItemCount(customizable.seed) >= amountSeed then
        onSeed(thread,id)
    elseif bot.gem_count >= mingems and buypack then
        buying()
        onPack(thread,id)
    end
end

harvest = function(thread,door,tiles)
    bot.auto_collect = true
    printed:append('Harvesting')
    for i, tile in pairs(tiles) do
        if isHarvested(tile.x,tile.y) then
            while not bot:isInTile(tile.x,tile.y) do
                bot:findPath(tile.x,tile.y)
                reconnect(thread,door,tile.x,tile.y)
            end
            for i = 1, 10 do
                if getTile(tile.x,tile.y):canHarvest() then
                    bot:hit(tile.x,tile.y)
                    sleep(delayharvest)
                    reconnect(thread,door,tile.x,tile.y)
                else
                    break
                end
            end
            if tile.y % 4 == 1 then
                if (tile.x + 1) < 100 then
                    if getTile(tile.x+1,tile.y):canHarvest() then
                        bot:hit(tile.x+1,tile.y)
                        reconnect(thread,door,tile.x,tile.y)
                    end
                end
            else
                if (tile.x - 1) >= 0 then
                    if getTile(tile.x-1,tile.y):canHarvest() then
                        bot:hit(tile.x-1,tile.y)
                        reconnect(thread,door,tile.x,tile.y)
                    end
                end
            end
        end
        inventoryItems(thread,door)
    end
end

local mainScript = function(init,id,tiles)
    local loopingObj = function(world,door,id)
        for _, obj in pairs(bot:getWorld():getObjects()) do
            if obj.id == id then
                bot:findPath(math.floor((obj.x + 10) / 32), math.floor((obj.y + 10) / 32))
                sleep(30)
                reconnect(world,door,math.floor((obj.x + 10) / 32), math.floor((obj.y + 10) / 32))
            end
            inventoryItems(world,door)
        end
    end
    local countFloating = function(id)
        local count = 0
        for _, obj in pairs(bot:getWorld():getObjects()) do
            if obj.id == id and #bot:getPath((obj.x + 10) // 32,(obj.y + 10) // 32) > 0 then
                count = count + 1
            end
        end
        return count
    end
    local countTree = function(tiles)
        local count = 0
        for _, tile in pairs(tiles) do
            if isHarvested(tile.x, tile.y) then
                count = count + 1
            end
        end
        return count
    end 
    warp(init,id)
    if not maxfind then
        if not nuked then
            if not wrong then
                localInfo('Harvesting')
                formattedTime = os.time()
                while countTree(tiles) > 0 do
                    harvest(init,id,tiles)
                end
                while countFloating(block) > 0 do
                    loopingObj(init,id,block)
                end
                while countFloating(112) > 0 do
                    loopingObj(init,id,112)
                end
                formattedTime = os.time() - formattedTime
                tableFormatted(string.sub(init,1,3)..' : '..(math.floor(formattedTime/60)..' Minutes'))
            else
                wrong = false
                saveFile(init,'Wrong door')
            end
        else
            nuked = false
            saveFile(init,'Nuked')
        end
    else
        maxfind = false
        textInfo('stop',bot.name..' too many finding worlds today, terminated script')
    end
end

if Information == 'Script Harvest made by Caramoy Syndicate, Link Discord : https://discord.com/invite/fTTKW8vvuq' and scriptVersion == '0.5' then
    if withproxy then
        setAuth()
    end
    sleep(pcallBot * delayexecute * 1000)
    if not multiplebot then
        for idx = start,stop do
            local world = splitPattern(farmTable[idx],'[^|]+')[1]
            local door = splitPattern(farmTable[idx],'[^|]+')[2]
            mainScript(world,door,tiles)
        end
    else
        for index, value in ipairs(farmTable) do
            local worlds = splitPattern(value,'[^|]+')[1]
            local doors = splitPattern(value,'[^|]+')[2]
            mainScript(worlds,doors,tiles)
        end
    end
    if removingbot then
        removeBot()
        sleep(2000)
    else
        warp(strGenerate,'')
    end
    localInfo('finished all world, terminated script!')
    textInfo('stop','finished all world, terminated script!')
else
    textInfo('stop','Script Harvest made by Caramoy Syndicate, Link Discord : https://discord.com/invite/fTTKW8vvuq, Reseller IDIOT !!')
end
