local bot = getBot()
local inventory = getBot():getInventory()
local printed = getBot():getLog()
local strGenerate = ''

for i = 1, 10 do
    strGenerate = strGenerate .. string.char(math.random(97, 122))
end

strFormatted = 'no farm has been finished yet'
local botBackup = {}
local initialize = {}
local onTile = {}
local farmList = {}
local indexPackX, indexPackY = 0, 0
local indexSeedX, indexSeedY = 0, 0
local indexBlockX, indexBlockY = 0, 0
local indexEventX, indexEventY = 0, 0

seed = block + 1
harvestTile = 5
local customizable = {
    index = 1, 
    indexBackup = 1, 
    formatTime = os.time()
}
local sleeping = delayexecute * 1000
local msg = {}

for i = math.floor(harvestTile/2), 1, -1 do
    i = i * -1
    table.insert(onTile, i)
end

for i = 0, math.ceil(harvestTile/2) - 1 do
    table.insert(onTile, i)
end

local events = {
    onNuke = function(variant, netid)
        if variant:get(0):getString() == 'OnConsoleMessage' then
            if variant:get(1):getString():lower():find('inaccessible.') or variant:get(1):getString():lower():find('unknown reason.') then
                nuked = true
            elseif variant:get(1):getString():lower():find('created too many worlds') or variant:get(1):getString():lower():find('unknown reason.') then
                maxfind = true
            end
            unlistenEvents()
        end
    end
} 

bot.legit_mode = false
bot.move_range = moveRange
bot.move_interval = moveInterval
bot.auto_reconnect = true
bot.collect_range = range

if ignoregems then
    bot.ignore_gems = true
end

itemFloat = function(id)
    return bot:getWorld().growscan:getObjects()[id] or 0
end

notifications = function(desc)
    messageBox = MessageBox.new()
    messageBox.title = 'Caramoy Syndicate'
    messageBox.description = desc
    messageBox:send()
end

readFile = function(fileName)
    local tbl = {}
    local file = io.open(fileName, 'r')
    if not file then
        if sendNotif then
            notifications('Fail to open ' .. fileName .. ' file.')
        end
        error('Failed to open file : ' .. fileName)
    else
        for line in file:lines() do
            table.insert(tbl, line)
        end
        file:close()
    end
    return tbl
end

spreadWorld = function(filesname, locpath)
    local infoTable = readFile(filesname)
    local totalBots = #getBots()
    local index = bot.index - 1
    local split = #infoTable / totalBots
    local start = math.floor(index * split) + 1
    local stop = math.floor((index + 1) * split)
    for i = start, stop do
        table.insert(locpath, infoTable[i])
    end
end

if autoSwitch then
    spreadWorld(switchFile, botBackup)
end

spreadWorld(worldFile, farmList)

createMessageID = function(url, content)
    if url ~= '' then
        url = url .. '?wait=1'
        local http = HttpClient.new()
        http.url = url
        http.headers['Content-Type'] = 'application/json'
        http:setMethod(Method.post)
        http.content = [[
        {
            "username":"Caramoy",
            "embeds": [
                {
                    "title":"]] .. content .. [[",
                    "color": ]] .. math.random(111111, 999999) .. [[
                }
            ]
        }
    ]]
        local result = http:request()
        if result.error == 0 then
            local resultData = result.body:match('"id"%s*:%s*"([^"]+)"')
            if resultData then
                writeFile('Bot Messages', resultData)
            end
            return resultData
        else
            print("Request Error: " .. result:getError())
        end
        return nil
    end
    return nil
end

fileExists = function(fileName)
    local file = io.open(fileName, "r")
    if file then
        file:close()
        return true
    else
        return false
    end
end

deleteFile = function(fileName)
    local result, reason = os.remove(fileName)
    if result then
        print(fileName .. " was deleted successfully.")
    else
        print("Error deleting " .. fileName .. ": " .. reason)
    end                                                                                                             
end

local fileName = "Bot Messages.txt"

if fileExists(fileName) then
    deleteFile(fileName)
end

activityDesc = function(text)
    while bot:isInWorld() and bot.status == BotStatus.online do
        bot:leaveWorld()
        sleep(5000)
    end
    if removingbot then
        removeBot()
        sleep(2000)
    end
    textInfo('stop', text)
end

itemRecycle = function(world, door)
    if inventory:getItemCount(block) > 0 then
        bot:sendPacket(2, 'action|trash\n|itemID|' .. block)
        sleep(delayrecycle)
        bot:sendPacket(2, 'action|dialog_return\ndialog_name|trash_item\nitemID|' .. block .. '|\ncount|' .. inventory:getItemCount(block))
        sleep(delayrecycle)
        reconnect(world, door)
    end
end

shuffle = function(tbl)
    for i = #tbl, 2, -1 do
        local j = math.random(i)
        tbl[i], tbl[j] = tbl[j], tbl[i]
    end
    return tbl
end

blockNum = shuffle(storageblock)
seedNum = shuffle(storageseed)
packNum = shuffle(storagepack)
eventNum = shuffle(storageevent)

writeFile = function(filename, threads)
    local file = io.open(filename .. '.txt', 'a')
    file:write(threads .. '\n')
    file:close()
end

setAuth = function()
    if withproxy then
        getProxyManager():setLimit(botperproxy)
        for idx, value in pairs(proxyList) do
            getProxyManager():addProxy(value)
        end
    end
end

splitPattern = function(str, ptr)
    if not ptr then 
        ptr = '%s'
    end
    local tbl = {}
    for string in string.gmatch(str, ptr) do
        table.insert(tbl, string) 
    end
    return tbl
end

clientStatic = function()
    local statusMap = {
        [BotStatus.offline] = 'Offline', 
        [BotStatus.account_banned] = 'Suspended', 
        [BotStatus.location_banned] = 'Location Banned', 
        [BotStatus.too_many_login] = 'Too Many Login', 
        [BotStatus.maintenance] = 'Maintenance', 
        [BotStatus.error_connecting] = 'Error Connecting', 
        [BotStatus.http_block] = 'HTTP Block', 
        [BotStatus.changing_subserver] = 'Changing Subserver', 
        [BotStatus.mod_entered] = 'Mod Entered'
    }
    return (statusMap[bot.status] or 'Online')
end

onTileWorld = function(case)
    local tiles = {}
    local botY = {2, 3}
    if case == 'harvest' then
        for _, startY in ipairs(botY) do
            for y = startY, 53, 6 do
                if ((y // 6) % 2 == 0) then
                    for x = 0, 99 do
                        table.insert(tiles, { x = x, y = y, fg = getTile(x, y).fg })
                    end
                else
                    for x = 99, 0, -1 do
                        table.insert(tiles, { x = x, y = y, fg = getTile(x, y).fg })
                    end
                end
            end
        end
    else
        for y = 0, 53 do
            if (y % 4 == 1) then
                for x = 0, 99 do
                    table.insert(tiles, { x = x, y = y, fg = getTile(x, y).fg })
                end
            else
                for x = 99, 0, -1 do
                    table.insert(tiles, { x = x, y = y, fg = getTile(x, y).fg })
                end
            end
        end
    end
    return tiles
end

tableFormatted = function(time)
    if strFormatted == 'no farm has been finished yet' then
        strFormatted = ''
    end
    strFormatted = strFormatted .. time .. '\n'
end

globalInfo = function(values)
    local str = ''
    local function processStorage(storage, message)
        if splitPattern(storage[customizable.index], '[^|]+')[1] ~= 'x' then
            for i = 1, #storage do
                str = str .. '\n||' .. string.upper(splitPattern(storage[i], '[^|]+')[1]) .. '|| : ' .. (initialize[splitPattern(storage[i], '[^|]+')[1]] or '?')
            end
            return str
        else
            return message
        end
    end
    if values == 'switch' then
        if autoSwitch then
            return processStorage(botBackup, 'Not using switch')
        else
            return 'Not using switch'
        end
    elseif values == 'block' then
        return processStorage(storageblock, '')
    elseif values == 'seed' then
        return processStorage(storageseed, '')
    elseif values == 'pack' then
        return processStorage(storagepack, 'Not using Storage Packs')
    elseif values == 'event' then
        return processStorage(storageevent, 'Not using Storage Events')
    end
    return str
end

countStatus = function(case)
    local count = 0
    for _, client in pairs(getBots()) do
        if case == 'offline' then
            if client.status ~= BotStatus.online then
                count = count + 1
            end
        else
            if client.status == BotStatus.account_banned then
                count = count + 1
            end
        end
    end
    return count
end

localInfo = function(info)
	if linkbotinfo ~= 'x' then
        for _, messages in pairs(msg) do
            realtime = os.time() - customizable.formatTime
            local webhook = Webhook.new(linkbotinfo)
            webhook.embed1.use = true
            webhook.embed2.use = true
            webhook.content = 'Caramoy | Message Bot - ' .. bot.index
            webhook.embed1.title = 'BOT - ' .. bot.index .. ' | Lucifer Harvest'
            webhook.embed1.thumbnail = 'https://cdn.discordapp.com/attachments/1222249842387193876/1224708077262082068/Hnet.com-image.jpg?ex=661e7947&is=660c0447&hm=e692ab165629d6a84ca2661b5b4a75f97a23cfabb98983fda3270bc2be0e7474&'
            webhook.embed1:addField("Bot Task", info, false)
            webhook.embed1:addField("Bot Name", '||' .. string.sub(bot.name, 1, 5) .. '||', true)
            webhook.embed1:addField('Bot Current', '||' .. string.sub(getWorld().name, 1, 5) .. '||', true)
            webhook.embed1:addField('Bot Status', clientStatic(), true)
            webhook.embed1:addField('Bot Level', bot.level, true)
            webhook.embed1:addField('Bot Age', bot:getAge() .. ' Days', true)
            webhook.embed1:addField('Bot Uptime', math.floor(realtime/86400) .. ':' .. math.floor(realtime%86400/3600) .. ':' .. math.floor(realtime%86400%3600/60) .. '', true)
            webhook.embed1:addField('Total Bots', #getBots(), true)
            webhook.embed1:addField('Total Offline', countStatus('offline'), true)
            webhook.embed1:addField('Total Banned', countStatus('banned'), true)
            webhook.embed1:addField('Storage Block', globalInfo('block'), false)
            webhook.embed1:addField('Storage Seed', globalInfo('seed'), true)
            webhook.embed1:addField('Storage Pack', globalInfo('pack'), true)
            webhook.embed1:addField('Storage Event', globalInfo('event'), true)
            webhook.embed2:addField('Farm Estimates', strFormatted, true)
            webhook.embed2:addField('Switch Account', globalInfo('switch'), true)
            webhook.embed2.footer.icon_url = 'https://cdn.discordapp.com/attachments/1222249842387193876/1224708077706543236/1712025730898.jpg?ex=661e7947&is=660c0447&hm=3be9efe2f0f23456f272149dc0844db884cee12f3b21199b35b2c1287c77a8f2&'
            webhook.embed2.footer.text = 'Updated : ' .. (os.date('!%a, %b %d %Y at %I:%M %p', os.time() + 7 * 60 * 60)) .. '.\nDeveloped By Caramoy and Made With Luv<3.'
            webhook:edit(messages)
        end
    end
end

clientContent = function(text)
    if webhookstatuslink ~= 'x'  then
        local webhook = Webhook.new(webhookstatuslink)
        if tagDiscord then
            webhook.content = '@everyone'
        end
        webhook.embed1.use = true
        webhook.embed1:addField('', text, false)
        webhook.embed1.footer.text = 'Webhook Status, sent at : ' .. (os.date('!%a %b %d, %Y at %I:%M %p', os.time() + 7 * 60 * 60)) .. ''
        webhook:send()
    end
end

textInfo = function(str, alphabet)
    printed:append(alphabet)
    clientContent('(' .. string.upper(bot.name) .. ') ' .. alphabet)
    if str == 'stop' then
        if sendNotif then
            notifications(string.upper(bot.name) .. ' : ' .. alphabet)
        end
        error(alphabet)
    end
end

detectTable = function(items, amt)
    for _, init in pairs(items) do
        if inventory:getItemCount(init) >= amt then
            return true
        end
    end
    return false
end

clientStatus = function(world, door)
    local name
    local doorId
    if world and door then
        name = world
        doorId = door
    end
    if bot.status ~= BotStatus.online then
        bot.auto_reconnect = false
        textInfo('', 'status is ' .. clientStatic() .. ', Current : ' .. getWorld().name .. '')
        localInfo('Bot Status is ' .. clientStatic())
        while bot.status ~= BotStatus.online do
            bot:connect()
            sleep(delayreconnect * 1000)
            if bot.status == BotStatus.account_banned then
                if switchOnSuspend then
                    onBackup(name, doorId)
                else
                    textInfo('stop', 'status is ' .. clientStatic() .. '')
                end
            elseif bot.status == BotStatus.maintenance then
                textInfo('', 'Server is maintenance, Sleeping for ' .. delaymaintenance .. ' minutes')
                sleep(delaymaintenance * 60000)
            end
        end
        textInfo('', 'status is ' .. clientStatic() .. ', Current : ' .. getWorld().name .. '')
        localInfo('Bot Status is ' .. clientStatic())
        bot.auto_reconnect = true
    end
end

reconnect = function(world, id, x, y)
    if bot.status ~= BotStatus.online then
        clientStatus(world, id)
    end
    if not bot:isInWorld(world:upper()) then
        addEvent(Event.variantlist, events.onNuke)
        while not bot:isInWorld(world:upper()) and not nuked and not maxfind do
            bot:warp(world:upper())
            listenEvents(5)
            sleep(delaywarp * 1000)
        end
        removeEvent(Event.variantlist)
    end 
    if bot:isInWorld(world:upper()) and id ~= '' then
        while getTile(bot.x, bot.y).fg == 6 do
            bot:warp(world:upper(), id:upper())
            sleep(delaywarp * 1000)
        end
    end
    if getTile(bot.x, bot.y).fg == 6 and id ~= '' then
        while getTile(bot.x, bot.y).fg == 6 do
            bot:warp(world:upper(), id:upper())
            sleep(delaywarp * 1000)
        end
    end
    if x and y then
        while bot.x ~= x or bot.y ~= y do
            bot:findPath(x, y)
            sleep(150)
        end
    end
end

warp = function(world, door)
    name = world
    if door ~= '' then
        name = name .. '|'  .. door
    end
    if not bot:isInWorld(world:upper()) then
        local count = 0
        addEvent(Event.variantlist, events.onNuke)
        while not bot:isInWorld(world:upper()) and not nuked and not maxfind do
            clientStatus()
            bot:warp(name)
            listenEvents(5)
            sleep(delaywarp * 1000)
            count = count + 1
            if count == 25 then
                count = 0
                textInfo('', ': Maybe hard warp?, disconnecting bot and sleeping for ' .. delayidiotserver .. ' minutes')
                bot:disconnect()
                sleep(delayidiotserver * 60000)
            end
        end
        removeEvent(Event.variantlist)
    end
    if bot:isInWorld(world:upper()) and door ~= '' then
        local stuck  = 0
        while getTile(bot.x, bot.y).fg == 6 and not wrong do
            clientStatus()
            bot:warp(name)
            sleep(delaywarp * 1000)
            stuck = stuck + 1
            if stuck == 5 then
                wrong = true
            end
        end
    end
end

isHarvested = function(ex, ye)
    return getTile(ex, ye).fg == seed and getTile(ex, ye):canHarvest() and bot:getWorld():hasAccess(ex, ye) ~= 0 and getTile(ex, ye).flags < 4096
end

countFloating = function(itm)
    local count = 0
    for _, obj in pairs(bot:getWorld():getObjects()) do
        if obj.id == itm and (#getBot():getPath(math.floor(obj.x / 32), math.floor(obj.y / 32)) ~= 0) then
            count = count + obj.count
        end
    end
    return count
end

countTree = function()
    local count = 0
    for _, tile in pairs(onTileWorld()) do
        if isHarvested(tile.x, tile.y) then
            count = count + 1
        end
    end
    return count
end 

shortcut = function(thread, id)
    printed:append('Harvesting')
    warp(thread, id)
    localInfo('Harvesting')
    bot.auto_collect = true
end

joinRandom = function()
    if clearhistory then
        printed:append('Clearing history')
        localInfo('Clearing history')
        for _, value in pairs(worldclearhistory) do
            warp(value, '')
            if not maxfind then
                if not nuked then
                    reconnect(value, '')
                else
                    nuked = false
                    activityDesc('World clearing history has nuked, Script terminated.')
                end
            else
                maxfind = false
                activityDesc('Too many creating worlds today, Script terminated.')
            end
        end
    end
    if offAfterJoinRandom then
        while bot.status == BotStatus.online do
            bot:disconnect()
            sleep(5000)
        end
        clientStatus()
    end
end

buying = function()
    printed:append('Buying packs')
    localInfo('Buying Pack')
    while upbackpack and inventory.slotcount < 36 and bot.gem_count > 500 do
        printed:append('Upgrading backpacks')
        bot:sendPacket(2, 'action|buy\nitem|upgrade_backpack')
        sleep(1000)
    end
    while bot.gem_count >= pricepack do
        bot:sendPacket(2, 'action|buy\nitem|' .. debug)
        sleep(1000)
        if detectTable(packList, 200) then
            break
        end
    end
end

checkPosObject = function(id)
    local count = 0
    for _, tile in pairs(bot:getWorld():getTiles()) do
        if tile.fg == id or tile.bg == id then
            count = count + 1
        end
    end
    return count
end

onEvent = function(thread, id)
    printed:append('Dropping events')
    for i = #eventNum, 1, -1 do
        parts = splitPattern(eventNum[i], '[^|]+')
        world, door = parts[1], parts[2]
        bot.auto_collect = false
        warp(world, door)
        if not nuked then
            if not wrong then
                localInfo('Dropping Events')
                clientStatus()
                if itemFloat(eventList[1]) >= limitevent then
                    initialize[world] = itemFloat(eventList[1]) .. 'x [LIMIT]'
                    textInfo('', 'Storage event : ' .. world .. ' has reached limit, skipped world')
                    indexEventX = 0
                    table.remove(eventNum, i)
                    if #eventNum == 0 then
                        activityDesc('All events storage has reached limit')
                    end
                else
                    for y, pack in pairs(eventList) do
                        for i, tile in pairs(bot:getWorld():getTiles()) do
                            ::BACK::
                            if posEvent ~= 0 then
                                if checkPosObject(posEvent) == 0 then
                                    activityDesc('Cant find to position, check ur pos id configs')
                                end
                                if tile.fg == posEvent or tile.bg == posEvent then
                                    bot:findPath(tile.x + (indexEventX), tile.y - (indexEventY))
                                    sleep(100)
                                    local count = 0
                                    reconnect(world, door, tile.x + (indexEventX), tile.y - (indexEventY))
                                    if tile.x + (indexEventX) >= 98 then
                                        indexEventY = indexEventY + 1
                                        indexEventX = 0
                                        goto BACK
                                    end
                                    while inventory:getItemCount(pack) > 0 do
                                        bot:setDirection(true)
                                        bot:drop(pack, 200)
                                        sleep(delaydrop * 1000)
                                        reconnect(world, door, tile.x + (indexEventX), tile.y - (indexEventY))
                                        count = count + 1
                                        if count >= 2 then
                                            indexEventX = indexEventX + 1
                                            goto BACK
                                        end
                                    end
                                end
                            else
                                if #bot:getPath(eventX + (indexEventX), eventY - (indexEventY)) > 0 then
                                    bot:findPath(eventX + (indexEventX), eventY - (indexEventY))
                                    sleep(100)
                                    local count = 0
                                    reconnect(world, door, bot.x, bot.y)
                                    if eventX + (indexEventX) >= 98 then
                                        indexEventY = indexEventY + 1
                                        indexEventX = 0
                                        goto BACK
                                    end
                                    while inventory:getItemCount(pack) > 0 do
                                        bot:setDirection(true)
                                        bot:drop(pack, 200)
                                        sleep(delaydrop * 1000)
                                        reconnect(world, door, bot.x, bot.y)
                                        count = count + 1
                                        if count >= 2 then
                                            indexEventX = indexEventX + 1
                                            goto BACK
                                        end
                                    end
                                else
                                    indexEventX = indexEventX + 1
                                    goto BACK
                                end
                            end
                            if inventory:getItemCount(pack) == 0 then
                                break
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                textInfo('', 'Storage event : ' .. world .. ' are wrong door id, Skipped world.')
                indexEventX = 0
                table.remove(eventNum, i)
                if #eventNum == 0 then
                    activityDesc('All events storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            textInfo('', 'Storage event : ' .. world .. ' are Nuked, Skipped world.')
            indexEventX = 0
            table.remove(eventNum, i)
            if #eventNum == 0 then
                activityDesc('All events storage has reached limit')
            end
        end 
    end
    initialize[world] = itemFloat(eventList[1]) .. 'x'
    joinRandom()
    shortcut(thread, id)
end

onPack = function(thread, id)
    printed:append('Dropping packs')
    for i = #packNum, 1, - 1 do
        parts = splitPattern(packNum[i], '[^|]+')
        world, door = parts[1], parts[2]
        bot.auto_collect = false
        warp(world, door)
        if not nuked then
            if not wrong then
                localInfo('Dropping packs')
                clientStatus()
                if itemFloat(packList[1]) >= limitpack then
                    initialize[world] = itemFloat(packList[1]) .. 'x [LIMIT]'
                    textInfo('', 'Storage packs : ' .. world .. ' has reached limit, skipped world')
                    indexPackX = 0
                    table.remove(packNum, i)
                    if #packNum == 0 then
                        activityDesc('All packs storage has reached limit')
                    end
                else
                    for y, pack in ipairs(packList) do
                        for i, tile in pairs(bot:getWorld():getTiles()) do
                            ::BACK::
                            if posPack ~= 0 then
                                if checkPosObject(posPack) == 0 then
                                    activityDesc('Cant find to position, check ur pos id configs')
                                end
                                if tile.fg == posPack or tile.bg == posPack then
                                    bot:findPath(tile.x + (indexPackX), tile.y - (indexPackY))
                                    sleep(100)
                                    local count = 0
                                    reconnect(world, door, tile.x + (indexPackX), tile.y - (indexPackY))
                                    if tile.x + (indexPackX) >= 98 then
                                        indexPackY = indexPackY + 1
                                        indexPackX = 0
                                        goto BACK
                                    end
                                    while inventory:getItemCount(pack) > 0 do
                                        bot:setDirection(true)
                                        bot:drop(pack, 200)
                                        sleep(delaydrop * 1000)
                                        reconnect(world, door, tile.x + (indexPackX), tile.y - (indexPackY))
                                        count = count + 1
                                        if count >= 2 then
                                            indexPackX = indexPackX + 1
                                            goto BACK
                                        end
                                    end
                                end
                            else
                                if #bot:getPath(packX + (indexPackX), packY - (indexPackY)) > 0 then
                                    bot:findPath(packX + (indexPackX), packY - (indexPackY))
                                    sleep(100)
                                    reconnect(world, door, bot.x, bot.y)
                                    local count = 0
                                    if packX + (indexPackX) >= 98 then
                                        indexPackY = indexPackY + 1
                                        indexPackX = 0
                                        goto BACK
                                    end
                                    while inventory:getItemCount(pack) > 0 do
                                        bot:setDirection(true)
                                        bot:drop(pack, 200)
                                        sleep(delaydrop * 1000)
                                        reconnect(world, door, bot.x, bot.y)
                                        count = count + 1
                                        if count >= 2 then
                                            indexPackX = indexPackX + 1
                                            goto BACK
                                        end
                                    end
                                else
                                    indexPackX = indexPackX + 1
                                    goto BACK
                                end
                            end
                            if inventory:getItemCount(pack) == 0 then
                                break
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                textInfo('', 'Storage packs : ' .. world .. ' are wrong door id, Skipped world.')
                indexPackX = 0
                table.remove(packNum, i)
                if #packNum == 0 then
                    activityDesc('All packs storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            textInfo('', 'Storage packs : ' .. world .. ' are Nuked, Skipped world.')
            indexPackX = 0
            table.remove(packNum, i)
            if #packNum == 0 then
                activityDesc('All packs storage has reached limit')
            end
        end 
    end
    initialize[world] = itemFloat(packList[1]) .. 'x'
    joinRandom()
    shortcut(thread, id)
end

onSeed = function(thread, id)
    printed:append('Dropping seeds')
    for i = #seedNum, 1, -1 do
        parts = splitPattern(seedNum[i], '[^|]+')
        world, door = parts[1], parts[2]
        bot.auto_collect = false
        warp(world, door)
        if not nuked then
            if not wrong then
                localInfo('Dropping seeds')
                clientStatus()
                if itemFloat(seed) >= limitseed then
                    initialize[world] = itemFloat(seed) .. 'x [LIMIT]'
                    textInfo('', 'Storage seeds : ' .. world .. ' has reached limit, skipped world')
                    indexSeedX = 0
                    table.remove(seedNum, i)
                    if #seedNum == 0 then
                        activityDesc('All seeds storage has reached limit')
                    end
                else
                    for i, tile in pairs(bot:getWorld():getTiles()) do
                        ::BACK::
                        if posSeed ~= 0 then
                            if checkPosObject(posSeed) == 0 then
                                activityDesc('Cant find to position, check ur pos id configs')
                            end
                            if tile.fg == posSeed or tile.bg == posSeed then
                                bot:findPath(tile.x + (indexSeedX), tile.y - (indexSeedY))
                                sleep(100)
                                local count = 0
                                reconnect(world, door, tile.x + (indexSeedX), tile.y - (indexSeedY))
                                if tile.x + (indexSeedX) >= 98 then
                                    indexSeedY = indexSeedY + 1
                                    indexSeedX = 0
                                    goto BACK
                                end
                                while inventory:getItemCount(seed) > 0 do
                                    bot:setDirection(true)
                                    bot:drop(seed, 200)
                                    sleep(delaydrop * 1000)
                                    reconnect(world, door, tile.x + (indexSeedX), tile.y - (indexSeedY))
                                    count = count + 1
                                    if count >= 2 then
                                        indexSeedX = indexSeedX + 1
                                        goto BACK
                                    end
                                end
                            end
                        else
                            if #bot:getPath(seedX + (indexSeedX), seedY - (indexSeedY)) > 0 then
                                bot:findPath(seedX + (indexSeedX), seedY - (indexSeedY))
                                sleep(100)
                                local count = 0
                                reconnect(world, door, seedX + (indexSeedX), seedY - (indexSeedY))
                                if seedX + (indexSeedX) >= 98 then
                                    indexSeedY = indexSeedY + 1
                                    indexSeedX = 0
                                    goto BACK
                                end
                                while inventory:getItemCount(seed) > 0 do
                                    bot:setDirection(true)
                                    bot:drop(seed, 200)
                                    sleep(delaydrop * 1000)
                                    reconnect(world, door, seedX + (indexSeedX), seedY - (indexSeedY))
                                    count = count + 1
                                    if count >= 2 then
                                        indexSeedX = indexSeedX + 1
                                        goto BACK
                                    end
                                end
                            else
                                indexSeedX = indexSeedX + 1
                                goto BACK
                            end
                        end
                        if inventory:getItemCount(seed) == 0 then
                            break
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                textInfo('', 'Storage seeds : ' .. world .. ' are wrong door id, Skipped world.')
                indexSeedX = 0
                table.remove(seedNum, i)
                if #seedNum == 0 then
                    activityDesc('All seeds storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            textInfo('', 'Storage seeds : ' .. world .. ' are Nuked, Skipped world.')
            indexSeedX = 0
            table.remove(seedNum, i)
            if #seedNum == 0 then
                activityDesc('All seeds storage has reached limit')
            end
        end 
    end
    initialize[world] = itemFloat(seed) .. 'x'
    joinRandom()
    shortcut(thread, id)
end

onBlock = function(thread, id)
    printed:append('Dropping blocks')
    for i = #blockNum, 1, -1 do
        parts = splitPattern(blockNum[i], '[^|]+')
        world, door = parts[1], parts[2]
        bot.auto_collect = false
        warp(world, door)
        if not nuked then
            if not wrong then
                localInfo('Dropping blocks')
                clientStatus()
                if itemFloat(block) >= limitblock then
                    initialize[world] = itemFloat(block) .. 'x [LIMIT]'
                    textInfo('', 'Storage blocks : ' .. world .. ' has reached limit, skipped world')
                    indexBlockX = 0
                    table.remove(blockNum, i)
                    if #blockNum == 0 then
                        activityDesc('All blocks storage has reached limit')
                    end
                else
                    for i, tile in pairs(bot:getWorld():getTiles()) do
                        ::BACK::
                        if posBlock ~= 0 then
                            if checkPosObject(posBlock) == 0 then
                                activityDesc('Cant find to position, check ur pos id configs')
                            end
                            if tile.fg == posBlock or tile.bg == posBlock then
                                bot:findPath(tile.x + (indexBlockX), tile.y - (indexBlockY))
                                sleep(100)
                                local count = 0
                                reconnect(world, door, tile.x + (indexBlockX), tile.y - (indexBlockY))
                                if tile.x + (indexBlockX) >= 98 then
                                    indexBlockY = indexBlockY + 1
                                    indexBlockX = 0
                                    goto BACK
                                end
                                while inventory:getItemCount(block) > 0 do
                                    bot:setDirection(true)
                                    bot:drop(block, 200)
                                    sleep(delaydrop * 1000)
                                    reconnect(world, door, tile.x + (indexBlockX), tile.y - (indexBlockY))
                                    count = count + 1
                                    if count >= 2 then
                                        indexBlockX = indexBlockX + 1
                                        goto BACK
                                    end
                                end
                            end
                        else
                            if #bot:getPath(blockX + (indexBlockX), blockY - (indexBlockY)) > 0 then
                                bot:findPath(blockX + (indexBlockX), blockY - (indexBlockY))
                                sleep(100)
                                local count = 0
                                reconnect(world, door, blockX + (indexBlockX), blockY - (indexBlockY))
                                if blockX + (indexBlockX) >= 98 then
                                    indexBlockY = indexBlockY + 1
                                    indexBlockX = 0
                                    goto BACK
                                end
                                while inventory:getItemCount(block) > 0 do
                                    bot:setDirection(true)
                                    bot:drop(block, 200)
                                    sleep(delaydrop * 1000)
                                    reconnect(world, door, blockX + (indexBlockX), blockY - (indexBlockY))
                                    count = count + 1
                                    if count >= 2 then
                                        indexBlockX = indexBlockX + 1
                                        goto BACK
                                    end
                                end
                            else
                                indexBlockX = indexBlockX + 1
                                goto BACK
                            end
                        end
                        if inventory:getItemCount(block) == 0 then
                            break
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                textInfo('', 'Storage blocks : ' .. world .. ' are wrong door id, Skipped world.')
                indexBlockX = 0
                table.remove(blockNum, i)
                if #blockNum == 0 then
                    activityDesc('All blocks storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            textInfo('', 'Storage blocks : ' .. world .. ' are Nuked, Skipped world.')
            indexBlockX = 0
            table.remove(blockNum, i)
            if #blockNum == 0 then
                activityDesc('All blocks storage has reached limit')
            end
        end 
    end
    initialize[world] = itemFloat(block) .. 'x'
    joinRandom()
    shortcut(thread, id)
end

botsWearItem = function()
    if bot:isInWorld() then
        while inventory:getItemCount(idItemSupport) > 0 and not inventory:getItem(idItemSupport).isActive do
            bot:wear(idItemSupport)
            sleep(500)
        end
    end
end

wearingItemEvent = function()
    printed:append('Take support items')
    world = splitPattern(worldwearitem[customizable.index], '[^|]+')[1]
    door = splitPattern(worldwearitem[customizable.index], '[^|]+')[2]
    bot.auto_collect = true
    warp(world, door)
    if not nuked then
        if not wrong then
            if inventory:getItemCount(idItemSupport) == 0 and itemFloat(idItemSupport) >= keepItemSupport then
                for _, obj in pairs(bot:getWorld():getObjects()) do
                    if obj.id == idItemSupport and (#bot:getPath(math.floor((obj.x + 10) / 32), math.floor((obj.y + 10) / 32) > 0)) then
                        bot:findPath(math.floor((obj.x + 10) / 32), math.floor((obj.y + 10) / 32))
                        sleep(100)
                        reconnect(world, door, math.floor((obj.x + 10) / 32), math.floor((obj.y + 10) / 32))
                    end
                    if inventory:getItemCount(idItemSupport) >= keepItemSupport then
                        break
                    end
                end
                bot:moveRight()
                sleep(500)
                botsWearItem()
                bot:setDirection(true)
                sleep(300)
                bot.auto_collect = false
                while inventory:getItemCount(idItemSupport) > keepItemSupport do
                    bot:drop(idItemSupport, inventory:getItemCount(idItemSupport) - keepItemSupport)
                    sleep(delaydrop*1000)
                    reconnect(world, door, bot.x, bot.y)
                end
            else
                textInfo('', 'Support item is empty, Drop the support item right now! Bot sleeping for 30 seconds')
                sleep(30000)
            end
        else
            wrong = false
            activityDesc('Id door world take support items is wrong, check ur id door! Terminated script.')
        end
    else
        nuked = false
        activityDesc('World take support items is nuked, check ur world! Terminated script.')
    end
end

onBackup = function(world, id)
    printed:append('Bot : ' .. bot.name .. ' reached max level, switching bot')
    ::BACK::
    local names = getBot().name
    for idx = customizable.indexBackup, #botBackup do
        thread = splitPattern(botBackup[idx], '([^|]+)')[1]
        threading = splitPattern(botBackup[idx], '([^|]+)')[2]
        if typeaccount == 'normal' then
            bot:updateBot(thread, threading)
        elseif typeaccount == 'guest' then
            bot:updateBot(strGenerate, thread, threading)
        end
        sleep(delayloginbot * 1000)
        bot.auto_reconnect = false
        while bot.status ~= BotStatus.online do
            bot:connect()
            sleep(delayreconnect * 1000)
            if bot.status == BotStatus.account_banned then
                initialize[thread] = 'Suspended'
                writeFile('switchStatus', thread .. ' : status is Suspended')
                textInfo('', 'Bot : ' .. thread .. ' is suspended, skipped bot')
                customizable.indexBackup = customizable.indexBackup + 1
                if customizable.indexBackup > #botBackup then
                    activityDesc('No more bots to switch, sc terminated')
                end
                goto BACK
            elseif bot.status == BotStatus.wrong_password then
                initialize[thread] = 'Wrong Password'
                writeFile('switchStatus', thread .. ' : status is Wrong Password')
                textInfo('', 'Bot : ' .. thread .. ' is Wrong Password, skipped bot')
                customizable.indexBackup = customizable.indexBackup + 1
                if customizable.indexBackup > #botBackup then
                    activityDesc('No more bots to switch, sc terminated')
                end
                goto BACK
            elseif bot.status == BotStatus.advanced_account_protection then
                initialize[thread] = 'AAP Authentication'
                writeFile('switchStatus', thread .. ' : status is AAP Authentication')
                textInfo('', 'Bot : ' .. thread .. ' is AAP Authentication, skipped bot')
                customizable.indexBackup = customizable.indexBackup + 1
                if customizable.indexBackup > #botBackup then
                    activityDesc('No more bots to switch, sc terminated')
                end
                goto BACK
            end
        end
        if bot.status == BotStatus.online and bot.level < switchOnLevel then
            initialize[thread] = 'Used'
            if not customizable.indexBackup > #botBackup then
                customizable.indexBackup = customizable.indexBackup + 1
            end
            break
        elseif bot.status == BotStatus.online and bot.level >= switchOnLevel then
            initialize[thread] = 'Reached max level'
            customizable.indexBackup = customizable.indexBackup + 1
            if customizable.indexBackup > #botBackup then
                activityDesc('No more bots to switch, sc terminated')
            end
            goto BACK
        end
    end
    textInfo('', 'Succes switching bots ' .. names .. ' to > ' .. bot.name .. '')
    shortcut(world, id)
end

saveFile = function(worlds, str)
    writeFile('WorldInfo', worlds .. ' : is ' .. str)
    tableFormatted(string.sub(worlds, 1, 3) .. ' | ' .. str)
    textInfo('', worlds ..  ' : is ' .. str .. ', skipped world')
end

droppingItems = function(thread, id)
    if not recycle then
        if inventory:getItemCount(block) > 0 then
            onBlock(thread, id)
        end
    end
    if inventory:getItemCount(seed) > 0 then
        onSeed(thread, id)
    end
    if detectTable(eventList, 1) then
        onEvent(thread, id)
    end
end

inventoryItems = function(thread, id)
    if inventory:getItemCount(idItemSupport) == 0 and wearingItemSupport then
        while inventory:getItemCount(idItemSupport) == 0 do
            wearingItemEvent(thread, id)
        end
        shortcut(thread, id)
    elseif switchOnLevel ~= 0 and bot.level >= switchOnLevel then
        if autoSwitch then
            droppingItems(thread, id)
            onBackup(thread, id)
        else
            droppingItems(thread, id)
            activityDesc('Bot reached max level')
        end
    elseif inventory:getItemCount(block) >= amountBlock then
        if recycle then
            itemRecycle(thread, id)
        else
            onBlock(thread, id)
        end
    elseif detectTable(eventList, amountEvent) then
        onEvent(thread, id)
    elseif inventory:getItemCount(seed) >= amountSeed then
        onSeed(thread, id)
    elseif bot.gem_count >= mingems and buypack then
        buying()
        onPack(thread, id)
    end
end

botHarvesting = function(x, y, tbl)
    for _, num in pairs(onTile) do
        if isHarvested(x + num, y + tbl) then
            return true
        end
    end
    return false
end

botHarvest = function(w, d)
    local directions = {-2, 0, 2}
    for _, v in pairs(directions) do
        local count = 0
        while botHarvesting(bot.x, bot.y, v) and count < 30 do
            for _, i in pairs(onTile) do
                if isHarvested(bot.x + i, bot.y + v) then
                    bot:hit(bot.x + i, bot.y + v)
                    sleep(delayharvest)
                    reconnect(w, d, bot.x, bot.y)
                end
            end
            count = count + 1
        end
    end
end

harvest = function(thread, id)
    bot.auto_collect = true
    printed:append('Harvesting')    
    for _, tile in pairs(onTileWorld('harvest')) do
        if isHarvested(tile.x, tile.y) then
            bot:findPath(tile.x, tile.y)
            sleep(100)
            reconnect(thread, id, tile.x, tile.y)
            if ((tile.y // 6) % 2 == 0) then
                if (tile.x + 2) > 96 then
                    bot:findPath(96, tile.y)
                    sleep(100)
                    reconnect(thread, id, 96, tile.y)
                else
                    bot:findPath(tile.x + 2, tile.y)
                    sleep(100)
                    reconnect(thread, id, tile.x + 2, tile.y)
                end
            else
                if (tile.x - 2) < 3 then
                    bot:findPath(3, tile.y)
                    sleep(100)
                    reconnect(thread, id, 3, tile.y)
                else
                    bot:findPath(tile.x - 2, tile.y)
                    sleep(100)
                    reconnect(thread, id, tile.x - 2, tile.y)
                end
            end
            botHarvest(thread, id)
        end
        inventoryItems(thread, id)
    end
end

rechecking = function(world, id)
    printed:append('Rechecking')
    for _, tile in pairs(onTileWorld('recheck')) do
        if isHarvested(tile.x, tile.y) then
            bot:findPath(tile.x, tile.y)
            sleep(100)
            local count = 0
            reconnect(world, id, tile.x, tile.y)
            while isHarvested(tile.x, tile.y) and count < 25 do
                bot:hit(tile.x, tile.y)
                sleep(delayharvest)
                reconnect(world, id, tile.x, tile.y)
                count = count + 1
            end
        end
        inventoryItems(world, id)
    end
end

collectFloat = function(worlds, id, itm)
    while countFloating(itm) > 0 do
        for _, obj in pairs(bot:getWorld():getObjects()) do
            if obj.id == itm and (#getBot():getPath(math.floor(obj.x / 32), math.floor(obj.y / 32)) ~= 0) then
                bot:findPath(math.floor(obj.x / 32), math.floor(obj.y / 32))
                sleep(100)
                reconnect(worlds, id, math.floor(obj.x / 32), math.floor(obj.y / 32))
                break
            end
        end
        inventoryItems(worlds, id)
    end
end

mainScript = function(worlds, id)
    localInfo('Harvesting')
    warp(worlds, id)
    if not maxfind then
        if not nuked then
            if not wrong then
                formattedTime = os.time()
                harvest(worlds, id)
                local count = 0
                while countTree(worlds, id) > 0 and count < 30 do
                    rechecking(worlds, id)
                    count = count + 1
                end
                collectFloat(worlds, id, block)
                collectFloat(worlds, id, seed)
                if not ignoregems then
                    collectFloat(worlds, id, 112)
                end
                droppingItems(worlds, id)
                formattedTime = os.time() - formattedTime
                tableFormatted(string.sub(worlds, 1, 3) .. ' | ' .. (math.floor(formattedTime/60) .. ' Minutes'))
            else
                wrong = false
                saveFile(worlds, 'Wrong door')
            end
        else
            nuked = false
            saveFile(worlds, 'Nuked')
        end
    else
        maxfind = false
        activityDesc('too many finding worlds today, terminated script')
    end
end

if Information == 'Script Harvest made by Caramoy Syndicate, Link Discord : https://discord.com/invite/fTTKW8vvuq' and scriptVersion == '0.5' then
    if withproxy then
        setAuth()
    end
    clientStatus()
    sleep(bot.index * sleeping)
    if linkbotinfo ~= 'x' then
        createMessageID(linkbotinfo, 'Creating message ID for Bot - '..bot.index)
        local readMsg = readFile('Bot Messages.txt')
        local indexMsg = 1
        for i = 1, indexMsg do
            table.insert(msg, readMsg[math.floor((getBot().index - 1) * indexMsg + i)])
        end
    end
    localInfo('Harvesting')
    for _, worldlist in pairs(farmList) do
        parts = splitPattern(worldlist, '[^|]+')
        mainScript(parts[1], parts[2])
    end
    activityDesc('finished all world, terminated script!')
else
    textInfo('stop', 'Script Harvest made by Caramoy Syndicate, Link Discord : https://discord.com/invite/fTTKW8vvuq, Reseller IDIOT !!')
end
