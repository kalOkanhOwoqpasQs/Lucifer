
for i, bot in pairs(getBots()) do
    if getBot().name:upper() == bot.name:upper() then
        pcallBot = i
    end
end

local bot = getBot()
local inventory = getBot():getInventory()
local printed = getBot():getLog()
strFormatted = 'None'
botBackup = {}
initialize = {}
reversed = {}
botTile = {}
initPosition = 5
local customizable = {
    seed = block + 1,
    index = 1,
    indexPack = 0,
    indexSeed = 0,
    indexBlock = 0,
    indexEvent = 0,
    indexMessage = 1,
    indexBackup = 1,
    variableBlock = 1,
    variableSeed = 1,
    variablePack = 1,
    variableEvent = 1,
    formatTime = os.time(),
    seedX = dropseedX - 1,
    seedY = dropseedY - 1,
    packX = droppackX - 1,
    packY = droppackY - 1,
    blockX = dropblockX - 1,
    blockY = dropblockY - 1,
    eventX = dropeventX - 1,
    eventY = dropeventY -1
}
local increment = 1 * 2 * 3
local customLine = #getBots() * 2 * 3
bot.legit_mode = false
bot.move_range = moveRange
bot.move_interval = moveInterval
bot.auto_reconnect = false
bot.collect_range = range
if ignoregems then
    bot.ignore_gems = true
end

customizable.notifications = function(desc)
    messageBox = MessageBox.new()
    messageBox.title = 'Caramoy Syndicate'
    messageBox.description = desc
    messageBox:send()
end

for i =  1,customizable.indexMessage do
    table.insert(reversed,messageidbotinfo[math.floor((pcallBot - 1) * customizable.indexMessage + i)])
end
for x = math.floor(initPosition/2),1,-1 do
    x = x * -1
    table.insert(botTile,x)
end
for x = 0, math.ceil(initPosition/2) - 1 do
    table.insert(botTile,x)
end

local function readFile(fileContents, fileNames)
    local allFilesContents = {}
    for i, fileName in ipairs(fileNames) do
        local file = io.open(fileName, 'r')
        if not file then
            customizable.notifications('Fail to open file '..fileName..'.')
            return nil
        else
            local fileContent = {}
            for line in file:lines() do
                table.insert(fileContent, line)
            end
            file:close()
            table.insert(fileContents, fileContent)
        end
    end
    return fileContents
end

if autoSwitch then
    local switchTable = {}
    local files = {switchFile}
    local text = readFile({},files)
    if text then
        for i, fileContent in ipairs(text) do
            for _, line in ipairs(fileContent) do
                table.insert(switchTable,line)
            end
        end
    end
    local onIndex = pcallBot - 1
    local onSplit = #switchTable / #getBots()
    local onStart = math.floor(onIndex * onSplit + 1)
    local onStop = math.floor(onIndex + 1) * onSplit
    for i = onStart, onStop do
        table.insert(botBackup,switchTable[i])
    end
end
local farmTable = {}
local files = {worldFile}
local text = readFile({},files)
if text then
    for i, fileContent in ipairs(text) do
        for _, line in ipairs(fileContent) do
            table.insert(farmTable,line)
        end
    end
end
local index = pcallBot - 1
local split = #farmTable / #getBots()
local start = math.floor(index * split + 1)
local stop = math.floor(index + 1) * split

customizable.itemRecycle = function()
    if inventory:getItemCount(block) > 0 then
        bot:sendPacket(2,'action|trash\n|itemID|'..block)
        sleep(500)
        bot:sendPacket(2,'action|dialog_return\ndialog_name|trash_item\nitemID|' .. block .. '|\ncount|' .. inventory:getItemCount(block))
        sleep(500)
    end
end

customizable.isHarvested = function(ex,ye)
    return getTile(ex,ye).fg == customizable.seed and getTile(ex,ye):canHarvest() and bot:getWorld():hasAccess(ex,ye) > 0 and getTile(ex,ye).flags < 4096
end

customizable.hitFarmable = function(x,y,str)
    for _,idx in pairs(botTile) do
        if customizable.isHarvested(x + idx,y + str) then
            return true
        end
    end
    return false
end

customizable.onInventory = function(world,id,log)
    if inventory:getItemCount(idItemSupport) == 0 and wearingItemSupport then
        while inventory:getItemCount(idItemSupport) == 0 do
            customizable.wearingItemEvent()
        end
        printed:append(log)
        customizable.warp(world,id)
        customizable.localInfo(log)
        bot.auto_collect = true
    elseif autoSwitch and bot.level >= switchOnLevel then
        bot.auto_collect = false
        if inventory:getItemCount(block) > 0 then
            customizable.onBlock()
        end
        if inventory:getItemCount(customizable.seed) > 0 then
            customizable.onSeed()
        end
        customizable.onBackup()
        printed:append(log)
        customizable.warp(world,id)
        customizable.localInfo(log)
        bot.auto_collect = true
    elseif inventory:getItemCount(block) >= amountBlock then
        if recycle then
            customizable.itemRecycle()
        else
            customizable.onBlock()
            printed:append(log)
            customizable.warp(world,id)
            customizable.localInfo(log)
        end
        bot.auto_collect = true
    elseif customizable.detectTable(eventList,amountEvent) then
        customizable.onEvent()
        printed:append(log)
        customizable.warp(world,id)
        customizable.localInfo(log)
        bot.auto_collect = true
    elseif inventory:getItemCount(customizable.seed) >= amountSeed then
        customizable.onSeed()
        printed:append(log)
        customizable.warp(world,id)
        customizable.localInfo(log)
        bot.auto_collect = true
    elseif bot.gem_count >= mingems and buypack then
        customizable.buying()
        customizable.onPack()
        printed:append(log)
        customizable.warp(world,id)
        customizable.localInfo(log)
        bot.auto_collect = true
    end
end

customizable.writeFile = function(filename,threads)
    local file = io.open(filename..'.txt','a')
    file:write(threads..'\n')
    file:close()
end

customizable.setAuth = function()
    if withproxy then
        getProxyManager():setLimit(botperproxy)
        for idx, val in pairs(proxyList) do
            getProxyManager():addProxy(val)
        end
    end
end

customizable.split = function(str, ptr)
    if not ptr then 
        ptr = '%s'
    end
    local tbl = {}
    for string in string.gmatch(str, ptr) do
        table.insert(tbl, string) 
    end
    return tbl
end

customizable.initBot = function()
    if bot.status == BotStatus.online then
        return 'Online'
    elseif bot.status == BotStatus.account_banned  then
        return 'Suspended'
    elseif bot.status == BotStatus.error_connecting  then
        return 'Ercon'
    elseif bot.status == BotStatus.maintenance then
        return 'Maintenance'
    elseif bot.status == BotStatus.changing_subserver then
        return 'Changing Subserver'
    elseif bot.status == BotStatus.location_banned then
        return 'Location Banned'
    else
        return 'Disconnect'
    end
end

customizable.tableFormatted = function(time)
    if strFormatted == 'None' then
        strFormatted = ''
    end
    strFormatted = strFormatted .. time .. '\n'
end

customizable.localInfo = function(info)
    local globalInfo = function(values)
        str = ''
        if values == 'switch' then
            if autoSwitch then
                str = ''
                for i = 1,#botBackup do
                    local switch = customizable.split(botBackup[i],'[^|]+')[1]
                    str = str..'\n||'..string.upper(switch)..'|| ('..(initialize[switch] or '?')..')'
                end
            else
                return 'Not using switch'
            end
        elseif values == 'block' then
            for i = 1, #storageblock do
                local world = customizable.split(storageblock[i],'[^|]+')[1]
                str = str..'\n||'..string.upper(world)..'|| : '..(initialize[world] or '?')..''
            end
        elseif values == 'seed' then
            for i = 1, #storageseed do
                local world = customizable.split(storageseed[i],'[^|]+')[1]
                str = str..'\n||'..string.upper(world)..'|| : '..(initialize[world] or '?')..''
            end
        elseif values == 'packevent' then
            for i = 1, #storagepack do
                local world = customizable.split(storagepack[i],'[^|]+')[1]
                str = str..'\nPack - '..i..' : '..(initialize[world] or '?')..''
            end
            
            for i = 1, #storageevent do
                local world = customizable.split(storageevent[i],'[^|]+')[1]
                str = str..'\nEvent - '..i..' : '..(initialize[world] or '?')..''
            end
        end
        return str
    end
	if linkbotinfo ~= 'x' then
        realtime = os.time() - customizable.formatTime
        for idx, val in pairs(reversed) do
            local webhook = Webhook.new(linkbotinfo)
            webhook.embed1.use = true
            webhook.embed2.use = true
            webhook.embed1.title = 'Caramoy Syndicate [https://discord.com/invite/fTTKW8vvuq]'
            webhook.embed1.color = math.random(111111,999999)
            webhook.embed1:addField('','Script running for **'..math.floor(realtime/86400)..' Days '..math.floor(realtime%86400/3600)..' Hours '..math.floor(realtime%86400%3600/60)..' Minutes**',false)
            webhook.embed1:addField('Bot Task',info,true)
            webhook.embed1:addField('Bot Name','['..bot.level..'] '..string.upper(bot.name),true)
            webhook.embed1:addField('Bot Gems',bot.gem_count,true)
            webhook.embed1:addField('Bot Current',getWorld().name,true)
            webhook.embed1:addField('Bot Status',customizable.initBot(),true)
            webhook.embed1:addField('Bot Switch',globalInfo('switch'),true)
            webhook.embed1:addField('Storage Block',globalInfo('block'),true)
            webhook.embed1:addField('Storage Seed',globalInfo('seed'),true)
            webhook.embed1:addField('Storage Pack & Event',globalInfo('packevent'),true)
            webhook.embed2:addField('Farm Estimates',strFormatted,true)
            webhook.embed2.footer.text = '[Lucifer] : Harvest Script\nLast update : '..(os.date('!%a %b %d, %Y at %I:%M %p', os.time() + 7 * 60 * 60))..''
            webhook:edit(val)
        end    
    end
end

customizable.initializeBots = function(text)
    if webhookstatuslink ~= 'x'  then
        local webhook = Webhook.new(webhookstatuslink)
        webhook.content = '@everyone'
        webhook.embed1.use = true
        webhook.embed1:addField('',text,false)
        webhook.embed1.footer.text = 'Webhook Status, sent at : '..(os.date('!%a %b %d, %Y at %I:%M %p', os.time() + 7 * 60 * 60))..''
        webhook:send()
    end
end

customizable.textInfo = function(str,alphabet)
    printed:append(alphabet)
    customizable.initializeBots('('..string.upper(bot.name)..') '..alphabet)
    if str == 'stop' then
        customizable.notifications(string.upper(bot.name)..' : '..alphabet)
        error(alphabet)
    end
end

customizable.reconnect = function(world,id,x,y)
    if not bot:isInWorld(world:upper()) or bot.status ~= BotStatus.online then
        customizable.textInfo('','status is '..customizable.initBot()..' Current : '..getWorld().name..'')
        while bot.status ~= BotStatus.online do
            bot:connect()
            if bot.status == BotStatus.account_banned then
                customizable.textInfo('stop','status is '..customizable.initBot()..'')
            else
                if bot.status == BotStatus.maintenance then
                    customizable.textInfo('','Server is maintenance, Sleeping for '..delaymaintenance..' minutes')
                    sleep(delaymaintenance * 60000)
                else
                    sleep(delayreconnect * 1000)
                end
            end
        end
        while not bot:isInWorld(world:upper()) do
            bot:warp(world:upper())
            sleep(delaywarp * 1000)
        end
        if id ~= '' then
            while getTile(bot.x,bot.y).fg == 6 do
                bot:warp(world:upper(),id:upper())
                sleep(delaywarp * 1000)
            end
        end
        if x and y then
            while bot.x ~= x or bot.y ~= y do
                bot:findPath(x,y)
                sleep(150)
            end
        end
        customizable.textInfo('','status is '..customizable.initBot()..', Current : '..getWorld().name..'')
    end
end

customizable.warp = function(world,door)
    name = world
    if door ~= '' then
        name = name .. '|' ..door
    end
    if not bot:isInWorld(world:upper()) then
        count = 0
        addEvent(Event.variantlist, function(variant, netid)
            if variant:get(0):getString() == 'OnConsoleMessage' then
                if variant:get(1):getString():lower():find('inaccessible.') or variant:get(1):getString():lower():find('unknown reason.') then
                    nuked = true
                end
            end
            if variant:get(1):getString():lower():find('created too many worlds') or variant:get(1):getString():lower():find('unknown reason.') then
                maxfind = true
            end
        end)
        while not bot:isInWorld(world:upper()) and not nuked and not maxfind do
            if bot.status ~= BotStatus.online then
                customizable.textInfo('','status is '..customizable.initBot()..'')
                while bot.status ~= BotStatus.online do
                    bot:connect()
                    if bot.status == BotStatus.account_banned then
                        customizable.textInfo('stop','status is '..customizable.initBot()..'')
                    else
                        if bot.status == BotStatus.maintenance then
                            sleep(delaymaintenance * 60000)
                        else
                            sleep(delayreconnect * 1000)
                        end
                    end
                end
                customizable.textInfo('','status is '..customizable.initBot()..'')
            end
            bot:warp(name)
            listenEvents(4)
            sleep(delaywarp * 1000)
            count = count + 1
            if count == hardWarpCount then
                count = 0
                customizable.textInfo('','Maybe hard warp?, disconnecting bot and sleeping for '..delayidiotserver..' minutes')
                bot:disconnect()
                sleep(delayidiotserver * 60000)
            end
        end
        removeEvents()
        sleep(1000)
    end
    if bot:isInWorld(world:upper()) then
        if door ~= '' then
            local stuck = 0
            while getTile(bot.x,bot.y).fg == 6 and not wrong do
                if bot.status ~= BotStatus.online then
                    customizable.textInfo('','status is '..customizable.initBot()..'')
                    while bot.status ~= BotStatus.online do
                        bot:connect()
                        if bot.status == BotStatus.account_banned then
                            customizable.textInfo('stop','status is '..customizable.initBot()..'')
                        else
                            if bot.status == BotStatus.maintenance then
                                sleep(delaymaintenance * 60000)
                            else
                                sleep(delayreconnect * 1000)
                            end
                        end
                    end
                    customizable.textInfo('','status is '..customizable.initBot()..'')
                end
                bot:warp(name)
                sleep(delaywarp * 1000)
                stuck = stuck + 1
                if stuck == 5 then
                    wrong = true
                end
            end
        end
    end
end

customizable.itemFloat = function(id)
    return bot:getWorld().growscan:getObjects()[id] or 0
end

customizable.joinRandom = function()
    if clearhistory then
        printed:append('Clearing history')
        customizable.localInfo('Clearing history')
        for _, value in pairs(worldclearhistory) do
            customizable.warp(value,'')
            if not maxfind then
                if not nuked then
                    customizable.reconnect(value,'')
                else
                    nuked = false
                    customizable.textInfo('stop','World clearing history has nuked, Script terminated.')
                end
            else
                maxfind = false
                customizable.textInfo('stop','Too many creating worlds today, Script terminated.')
            end
        end
    end
end

customizable.detectTable = function(items,amt)
    for _, init in pairs(items) do
        if inventory:getItemCount(init) >= amt then
            return true
        end
    end
    return false
end

customizable.buying = function()
    printed:append('Buying packs')
    customizable.localInfo('Buying Pack')
    if upbackpack and inventory.slotcount < 36 then
        printed:append('Upgrading backpacks')
        repeat
            bot:sendPacket(2,'action|buy\nitem|upgrade_backpack')
            sleep(1000)
        until inventory.slotcount >= 36
    end
    while bot.gem_count >= pricepack do
        bot:sendPacket(2,'action|buy\nitem|'..debug)
        sleep(1000)
        if customizable.detectTable(packList,200) then
            break
        end
    end
end

customizable.onEvent = function()
    printed:append('Dropping events')
    for i = customizable.variableEvent , #storageevent do
        world, door = customizable.split(storageevent[i],'[^|]+')[1], customizable.split(storageevent[i],'[^|]+')[2]
        customizable.warp(world,door)
        bot.auto_collect = false
        if not nuked then
            if not wrong then
                customizable.localInfo('Dropping Events')
                if customizable.itemFloat(eventList[1]) >= limitevent then
                    initialize[world] = customizable.itemFloat(eventList[1])..'x (LIMIT)'
                    customizable.textInfo('','Storage event : '..world..' has reached limit, skipped world')
                    customizable.variableEvent = customizable.variableEvent + 1
                    customizable.indexEvent = 0
                    if customizable.variableEvent > #storageevent then
                        initialize[world] = customizable.itemFloat(eventList[1])..'x (LIMIT)'
                        if removingbot then
                            removeBot()
                            sleep(2000)
                        else
                            customizable.warp(customizable.randomLetter(14),'')
                        end
                        customizable.localInfo('All events storage has reached limit')
                        customizable.textInfo('stop','All events storage has reached limit, Script terminated.')
                    end
                else
                    for y,pack in pairs(eventList) do
                        for i,tile in pairs(bot:getWorld():getTiles()) do
                            if tile.fg == 0 or tile.bg == 0 then
                                ::BACK::
                                bot:findPath(customizable.eventX + (customizable.indexEvent),customizable.eventY)
                                sleep(100)
                                local count = 0
                                customizable.reconnect(world,door,customizable.eventX + (customizable.indexEvent),customizable.eventY)
                                if customizable.eventX + (customizable.indexEvent) >= 98 then
                                    customizable.eventY = customizable.eventY - 1
                                    customizable.indexEvent = 0
                                end
                                while inventory:getItemCount(pack) > 0 do
                                    bot:setDirection(false)
                                    bot:drop(pack,200)
                                    sleep(delaydrop * 1000)
                                    customizable.reconnect(world,door,customizable.eventX + (customizable.indexEvent),customizable.eventY)
                                    count = count + 1
                                    if count >= 2 then
                                        customizable.indexEvent = customizable.indexEvent + 1
                                        goto BACK
                                    end
                                end
                            end
                            if inventory:getItemCount(pack) == 0 then
                                break
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                customizable.textInfo('','Storage event : '..world..' are wrong door id, Skipped world.')
                customizable.variableEvent = customizable.variableEvent + 1
                customizable.indexEvent = 0
                if customizable.variableEvent > #storageevent then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    else
                        customizable.warp(customizable.randomLetter(14),'')
                    end
                    customizable.localInfo('All events storage has reached limit')
                    customizable.textInfo('stop','All events storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            customizable.textInfo('','Storage event : '..world..' are Nuked, Skipped world.')
            customizable.variableEvent = customizable.variableEvent + 1
            customizable.indexEvent = 0
            if customizable.variableEvent > #storageevent then
                if removingbot then
                    removeBot()
                    sleep(2000)
                else
                    customizable.warp(customizable.randomLetter(14),'')
                end
                customizable.localInfo('All events storage has reached limit')
                customizable.textInfo('stop','All events storage has reached limit')
            end
        end 
    end
    initialize[world] = customizable.itemFloat(eventList[1])..'x'
    customizable.joinRandom()
end

customizable.onPack = function()
    printed:append('Dropping packs')
    for i = customizable.variablePack , #storagepack do
        world, door = customizable.split(storagepack[i],'[^|]+')[1], customizable.split(storagepack[i],'[^|]+')[2]
        customizable.warp(world,door)
        bot.auto_collect = false
        if not nuked then
            if not wrong then
                customizable.localInfo('Dropping packs')
                if customizable.itemFloat(packList[1]) >= limitpack then
                    initialize[world] = customizable.itemFloat(packList[1])..'x (LIMIT)'
                    customizable.textInfo('','Storage packs : '..world..' has reached limit, skipped world')
                    customizable.variablePack = customizable.variablePack + 1
                    customizable.indexPack = 0
                    if customizable.variablePack > #storagepack then
                        initialize[world] = customizable.itemFloat(packList[1])..'x (LIMIT)'
                        if removingbot then
                            removeBot()
                            sleep(2000)
                        else
                            customizable.warp(customizable.randomLetter(14),'')
                        end
                        customizable.localInfo('All packs storage has reached limit')
                        customizable.textInfo('stop','All packs storage has reached limit')
                    end
                else
                    for y,pack in pairs(packList) do
                        for i,tile in pairs(bot:getWorld():getTiles()) do
                            if tile.fg == 0 or tile.bg == 0 then
                                ::BACK::
                                bot:findPath(customizable.packX + (customizable.indexPack),customizable.packY)
                                sleep(100)
                                local count = 0
                                customizable.reconnect(world,door,customizable.packX + (customizable.indexPack),customizable.packY)
                                if customizable.packX + (customizable.indexPack) >= 98 then
                                    customizable.packY = customizable.packY - 1
                                    customizable.indexPack = 0
                                end
                                while inventory:getItemCount(pack) > 0 do
                                    bot:setDirection(false)
                                    bot:drop(pack,200)
                                    sleep(delaydrop * 1000)
                                    customizable.reconnect(world,door,customizable.packX + (customizable.indexPack),customizable.packY)
                                    count = count + 1
                                    if count >= 2 then
                                        customizable.indexPack = customizable.indexPack + 1
                                        goto BACK
                                    end
                                end
                            end
                            if inventory:getItemCount(pack) == 0 then
                                break
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                customizable.textInfo('','Storage packs : '..world..' are wrong door id, Skipped world.')
                customizable.variablePack = customizable.variablePack + 1
                customizable.indexPack = 0
                if customizable.variablePack > #storagepack then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    else
                        customizable.warp(customizable.randomLetter(14),'')
                    end
                    customizable.localInfo('All packs storage has reached limit')
                    customizable.textInfo('stop','All packs storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            customizable.textInfo('','Storage packs : '..world..' are Nuked, Skipped world.')
            customizable.variablePack = customizable.variablePack + 1
            customizable.indexPack = 0
            if customizable.variablePack > #storagepack then
                if removingbot then
                    removeBot()
                    sleep(2000)
                else
                    customizable.warp(customizable.randomLetter(14),'')
                end
                customizable.localInfo('All packs storage has reached limit')
                customizable.textInfo('stop','All packs storage has reached limit')
            end
        end 
    end
    initialize[world] = customizable.itemFloat(packList[1])..'x'
    customizable.joinRandom()
end

customizable.onSeed = function()
    printed:append('Dropping seeds')
    for i = customizable.variableSeed , #storageseed do
        world = customizable.split(storageseed[i],'[^|]+')[1]
        door = customizable.split(storageseed[i],'[^|]+')[2]
        customizable.warp(world,door)
        bot.auto_collect = false
        if not nuked then
            if not wrong then
                customizable.localInfo('Dropping seeds')
                if customizable.itemFloat(customizable.seed) >= limitseed then
                    initialize[world] = customizable.itemFloat(customizable.seed)..'x (LIMIT)'
                    customizable.textInfo('','Storage seeds : '..world..' has reached limit, skipped world')
                    customizable.variableSeed = customizable.variableSeed + 1
                    customizable.indexSeed = 0
                    if customizable.variableSeed > #storageseed then
                        initialize[world] = customizable.itemFloat(customizable.seed)..'x (LIMIT)'
                        if removingbot then
                            removeBot()
                            sleep(2000)
                        else
                            customizable.warp(customizable.randomLetter(14),'')
                        end
                        customizable.localInfo('All seeds storage has reached limit')
                        customizable.textInfo('stop','All seeds storage has reached limit')
                    end
                else
                    for i,tile in pairs(bot:getWorld():getTiles()) do
                        if tile.fg == 0 or tile.bg == 0 then
                            ::BACK::
                            bot:findPath(customizable.seedX + (customizable.indexSeed),customizable.seedY)
                            sleep(100)
                            local count = 0
                            customizable.reconnect(world,door,customizable.seedX + (customizable.indexSeed),customizable.seedY)
                            if customizable.seedX + (customizable.indexSeed) >= 98 then
                                customizable.seedY = customizable.seedY - 1
                                customizable.indexSeed = 0
                            end
                            while inventory:getItemCount(customizable.seed) > 0 do
                                bot:setDirection(false)
                                bot:drop(customizable.seed,200)
                                sleep(delaydrop * 1000)
                                customizable.reconnect(world,door,customizable.seedX + (customizable.indexSeed),customizable.seedY)
                                count = count + 1
                                if count >= 2 then
                                    customizable.indexSeed = customizable.indexSeed + 1
                                    goto BACK
                                end
                            end
                        end
                        if inventory:getItemCount(customizable.seed) == 0 then
                            break
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                customizable.textInfo('','Storage seeds : '..world..' are wrong door id, Skipped world.')
                customizable.variableSeed = customizable.variableSeed + 1
                customizable.indexSeed = 0
                if customizable.variableSeed > #storageseed then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    else
                        customizable.warp(customizable.randomLetter(14),'')
                    end
                    customizable.localInfo('All seeds storage has reached limit')
                    customizable.textInfo('stop','All seeds storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            customizable.textInfo('','Storage seeds : '..world..' are Nuked, Skipped world.')
            customizable.variableSeed = customizable.variableSeed + 1
            customizable.indexSeed = 0
            if customizable.variableSeed > #storageseed then
                if removingbot then
                    removeBot()
                    sleep(2000)
                else
                    customizable.warp(customizable.randomLetter(14),'')
                end
                customizable.localInfo('All seeds storage has reached limit')
                customizable.textInfo('stop','All seeds storage has reached limit')
            end
        end 
    end
    initialize[world] = customizable.itemFloat(customizable.seed)..'x'
    customizable.joinRandom()
end

customizable.onBlock = function()
    printed:append('Dropping blocks')
    for i = customizable.variableBlock , #storageblock do
        world = customizable.split(storageblock[i],'[^|]+')[1]
        door = customizable.split(storageblock[i],'[^|]+')[2]
        customizable.warp(world,door)
        bot.auto_collect = false
        if not nuked then
            if not wrong then
                customizable.localInfo('Dropping blocks')
                if customizable.itemFloat(block) >= limitblock then
                    initialize[world] = customizable.itemFloat(block)..'x (LIMIT)'
                    customizable.textInfo('','Storage blocks : '..world..' has reached limit, skipped world')
                    customizable.variableBlock = customizable.variableBlock + 1
                    customizable.indexBlock = 0
                    if customizable.variableBlock > #storageblock then
                        initialize[world] = customizable.itemFloat(block)..'x (LIMIT)'
                        if removingbot then
                            removeBot()
                            sleep(2000)
                        else
                            customizable.warp(customizable.randomLetter(14),'')
                        end
                        customizable.localInfo('All blocks storage has reached limit')
                        customizable.textInfo('stop','All blocks storage has reached limit')
                    end
                else
                    for i,tile in pairs(bot:getWorld():getTiles()) do
                        if tile.fg == 0 or tile.bg == 0 then
                            ::BACK::
                            bot:findPath(customizable.blockX + (customizable.indexBlock),customizable.blockY)
                            sleep(100)
                            local count = 0
                            customizable.reconnect(world,door,customizable.blockX + (customizable.indexBlock),customizable.blockY)
                            if customizable.blockX + (customizable.indexBlock) >= 98 then
                                customizable.blockY = customizable.blockY - 1
                                customizable.indexBlock = 0
                            end
                            while inventory:getItemCount(block) > 0 do
                                bot:setDirection(false)
                                bot:drop(block,200)
                                sleep(delaydrop * 1000)
                                customizable.reconnect(world,door,customizable.blockX + (customizable.indexBlock),customizable.blockY)
                                count = count + 1
                                if count >= 2 then
                                    customizable.indexBlock = customizable.indexBlock + 1
                                    goto BACK
                                end
                            end
                        end
                        if inventory:getItemCount(block) == 0 then
                            break
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                customizable.textInfo('','Storage blocks : '..world..' are wrong door id, Skipped world.')
                customizable.variableBlock = customizable.variableBlock + 1
                customizable.indexBlock = 0
                if customizable.variableBlock > #storageblock then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    else
                        customizable.warp(customizable.randomLetter(14),'')
                    end
                    customizable.localInfo('All blocks storage has reached limit')
                    customizable.textInfo('stop','All blocks storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            customizable.textInfo('','Storage blocks : '..world..' are Nuked, Skipped world.')
            customizable.variableBlock = customizable.variableBlock + 1
            customizable.indexBlock = 0
            if customizable.variableBlock > #storageblock then
                if removingbot then
                    removeBot()
                    sleep(2000)
                else
                    customizable.warp(customizable.randomLetter(14),'')
                end
                customizable.localInfo('All blocks storage has reached limit')
                customizable.textInfo('stop','All blocks storage has reached limit')
            end
        end 
    end
    initialize[world] = customizable.itemFloat(block)..'x'
    customizable.joinRandom()
end

customizable.recheckingWorld = function(threads,door)
    printed:append('Rechecking')
    bot.auto_collect = true
    for y = -1, 53 do
        for x = tileA, tileB, tileC do
            if customizable.isHarvested(x,y) then
                while not bot:isInTile(x,y) do
                    bot:findPath(x,y)
                    customizable.reconnect(threads,door,x,y)
                end
                for i = 1, 10 do
                    if customizable.isHarvested(x,y) then
                        bot:hit(x,y)
                        sleep(delayharvest)
                        customizable.reconnect(threads,door,x,y)
                    else
                        break
                    end
                end
            end
            customizable.onInventory(threads,door,'Rechecking')
        end
    end
    for idx, obj in ipairs(bot:getWorld():getObjects()) do
        if obj.id == block then
            if customizable.itemFloat(block) ~= 0 then
                bot:findPath(math.floor(obj.x / 32),math.floor(obj.y / 32))
                sleep(30)
                customizable.reconnect(threads,door,math.floor(obj.x / 32),math.floor(obj.y / 32))
            end
            customizable.onInventory(threads,door,'Rechecking')
        end
    end
    for idx, obj in ipairs(bot:getWorld():getObjects()) do
        if obj.id == 112 then
            if customizable.itemFloat(112) ~= 0 then
                bot:findPath(math.floor(obj.x / 32),math.floor(obj.y / 32))
                sleep(30)
                customizable.reconnect(threads,door,math.floor(obj.x / 32),math.floor(obj.y / 32))
            end
            customizable.onInventory(threads,door,'Rechecking')
        end
    end
end

customizable.pattern = function(world,id)
    botX = bot.x
    botY = bot.y
    local function harvestingTree(num,ptr)
        local tileY = 0
        if num == 'up' then
            tileY = botY - 2
        elseif num == 'mid' then
            tileY = botY
        elseif num == 'down' then
            tileY = botY + 2
        end
        count = 0
        while customizable.hitFarmable(botX,botY,ptr) do
            for _,i in pairs(botTile) do
                if customizable.isHarvested(botX + i,tileY) then
                    bot:hit(botX + i,tileY)
                    sleep(delayharvest)
                    customizable.reconnect(world,id,botX,botY)
                end
            end
            count = count + 1
            if count == 15 then
                count = 0
                break
            end
        end
    end
    if botX == 1 then
        botX = botX + 2
        bot:findPath(botX,botY)
        sleep(100)
    elseif botX == 2 then
        botX = botX + 1
        bot:findPath(botX,botY)
        sleep(100)
    elseif botX == 0 then
        botX = botX + 3
        bot:findPath(botX,botY)
        sleep(100)
    end
    harvestingTree('up',-2)
    harvestingTree('mid',0)
    harvestingTree('down',2)
end

customizable.harvestWorld = function(threads,door)
    tileA, tileB, tileC, tileD = 99, 0, -1, 0
    printed:append('Harvest')
    bot.auto_collect = true
    if not multiplebot then
        for val = 2,3 do
            for y = val, 53, increment do
                for x = tileA, tileB, tileC do
                    if customizable.isHarvested(x,y) and x >= 3 then
                        bot:findPath(x-2,y)
                        customizable.reconnect(threads,door,x-2,y)
                        customizable.pattern(threads,door)
                    end
                    customizable.onInventory(threads,door,'Harvest')
                end
            end
        end
    else
        for val = 2,3 do
            for y = val +  ((pcallBot - 1) * 6), 53, customLine do
                for x = tileA, tileB, tileC do
                    if customizable.isHarvested(x,y) and x >= 3 then
                        bot:findPath(x-2,y)
                        customizable.reconnect(threads,door,x-2,y)
                        customizable.pattern(threads,door)
                    end
                    customizable.onInventory(threads,door,'Harvest')
                end
            end
        end
    end
end

customizable.wearingItemEvent = function()
    printed:append('Take support items')
    world = customizable.split(worldwearitem[customizable.index],'[^|]+')[1]
    door = customizable.split(worldwearitem[customizable.index],'[^|]+')[2]
    customizable.warp(world,door)
    bot.auto_collect = false
    if not nuked then
        if not wrong then
            if inventory:getItemCount(idItemSupport) == 0 and customizable.itemFloat(idItemSupport) >= keepItemSupport then
                for _, obj in pairs(bot:getWorld():getObjects()) do
                    if obj.id == idItemSupport then
                        bot:findPath(math.floor(obj.x / 32),math.floor(obj.y / 32))
                        sleep(100)
                        bot:collect(range)
                        sleep(100)
                        customizable.reconnect(world,door,math.floor(obj.x / 32),math.floor(obj.y / 32))
                    end
                end
                bot:moveTo(1,0)
                sleep(500)
                bot:wear(idItemSupport)
                bot:setDirection(true)
                sleep(30)
                bot:drop(idItemSupport,inventory:getItemCount(idItemSupport) - keepItemSupport)
                sleep(1000)
                customizable.reconnect(world,door,bot.x,bot.y)
            else
                customizable.textInfo('','Support item is empty, Drop the support item right now!')
            end
        else
            wrong = false
            customizable.textInfo('stop','Id door world take support items is wrong, check ur id door!')
        end
    else
        nuked = false
        customizable.textInfo('stop','World take support items is nuked, check ur world!')
    end
end

customizable.randomLetter = function(length)
    local letter = ''
    local function stringRandom()
        local random = math.random(1,3)
        if random == 1 then
            return string.char(math.random(97,122))
        elseif random == 2 then
            return string.char(math.random(65,90))
        else
            return string.char(math.random(48,57))
        end
    end
    for i = 1, length do
        letter = letter..stringRandom()
    end
    return letter
end

customizable.onBackup = function()
    printed:append('Bot : '..bot.name..' reached max level, switching bot')
    ::BACK::
    for idx = customizable.indexBackup, #botBackup do
        thread, threading = customizable.split(botBackup[idx],'([^|]+)')[1], customizable.split(botBackup[idx],'([^|]+)')[2]
        if typeaccount == 'normal' then
            bot:updateBot(thread,threading)
        elseif typeaccount == 'guest' then
            bot:updateBot(customizable.randomLetter(lettername)..'',thread,threading)
        end
        sleep(delayloginbot * 1000)
        bot.auto_reconnect = false
        customizable.textInfo('','Succes switching bot to > '..bot.name..'')
        while bot.status ~= BotStatus.online do
            bot:connect()
            if bot.status == BotStatus.account_banned then
                initialize[thread] = 'Suspended'
                customizable.writeFile('switchStatus',thread..' : status is Suspended')
                customizable.textInfo('','Bot : '..thread..' is suspended, skipped bot')
                customizable.indexBackup = customizable.indexBackup + 1
                if customizable.indexBackup > #botBackup then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    end
                    customizable.localInfo('No more bots to switch, sc terminated')
                    customizable.textInfo('stop','No more bots to switch, sc terminated')
                end
                goto BACK
            else
                sleep(delayreconnect * 1000)
            end
        end
        if bot.status == BotStatus.online and bot.level < switchOnLevel then
            initialize[thread] = 'Used'
            break
        elseif bot.status == BotStatus.online and bot.level >= switchOnLevel then
            initialize[thread] = 'Reached max level'
            customizable.indexBackup = customizable.indexBackup + 1
            if customizable.indexBackup > #botBackup then
                if removingbot then
                    removeBot()
                    sleep(2000)
                end
                customizable.localInfo('No more bots to switch, sc terminated')
                customizable.textInfo('stop','No more bots to switch, sc terminated')
            end
            goto BACK
        end
    end
end

customizable.mainScript = function(init,id)
    customizable.warp(init,id)
    if not maxfind then
        if not nuked then
            if not wrong then
                customizable.localInfo('Harvesting')
                formattedTime = os.time()
                customizable.harvestWorld(init,id)
                for i = 1, recheckCount do
                    customizable.recheckingWorld(init,id)
                end
                formattedTime = os.time() - formattedTime
                customizable.tableFormatted(string.sub(init,1,3)..' : '..(math.floor(formattedTime/60)..' Minutes'))
            else
                wrong = false
                customizable.writeFile('worldInfo',init..' : is wrong id')
                customizable.tableFormatted(string.sub(init,1,3)..' : Wrong')
                customizable.textInfo('',init.. ' : is wrong door id, skipped world')
            end
        else
            nuked = false
            customizable.writeFile('worldInfo',init..' : Nuked')
            customizable.tableFormatted(string.sub(init,1,3)..' : Nuked')
            customizable.textInfo('',init..' : is Nuked, Skipped world.')
        end
    else
        maxfind = false
        customizable.textInfo('stop',bot.name..' too many finding worlds today, terminated script')
    end
end

if Information == 'Script Harvest made by Caramoy Syndicate, Link Discord : https://discord.com/invite/fTTKW8vvuq' and scriptVersion == '0.4' then
    if withproxy then
        customizable.setAuth()
    end
    sleep(pcallBot * delayexecute * 1000)
    if not multiplebot then
        for idx = start,stop do
            local world = customizable.split(farmTable[idx],'[^|]+')[1]
            local door = customizable.split(farmTable[idx],'[^|]+')[2]
            customizable.mainScript(world,door)
        end
    else
        for index, value in ipairs(farmTable) do
            local worlds = customizable.split(value,'[^|]+')[1]
            local doors = customizable.split(value,'[^|]+')[2]
            customizable.mainScript(worlds,doors)
        end
    end
    if removingbot then
        removeBot()
        sleep(2000)
    else
        customizable.warp(customizable.randomLetter(14),'')
    end
    customizable.localInfo('finished all world, terminated script!')
    customizable.textInfo('stop','finished all world, terminated script!')
else
    customizable.textInfo('stop','Script Harvest made by Caramoy Syndicate, Link Discord : https://discord.com/invite/fTTKW8vvuq, Reseller IDIOT !!')
end
